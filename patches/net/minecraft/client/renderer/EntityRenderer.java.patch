--- a/net/minecraft/client/renderer/EntityRenderer.java
+++ b/net/minecraft/client/renderer/EntityRenderer.java
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
+import com.google.common.primitives.Doubles;
 import com.google.gson.JsonSyntaxException;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
@@ -10,21 +11,28 @@
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import javax.vecmath.Color3f;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.Minecraft.renderPass;
 import net.minecraft.client.entity.AbstractClientPlayer;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.gui.Gui;
 import net.minecraft.client.gui.GuiDownloadTerrain;
 import net.minecraft.client.gui.GuiMainMenu;
+import net.minecraft.client.gui.GuiWinGame;
 import net.minecraft.client.gui.MapItemRenderer;
 import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.particle.ParticleManager;
@@ -43,6 +51,7 @@
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
+import net.minecraft.enchantment.Enchantment;
 import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLivingBase;
@@ -53,9 +62,12 @@
 import net.minecraft.entity.passive.EntityAnimal;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
+import net.minecraft.init.Enchantments;
+import net.minecraft.init.Items;
 import net.minecraft.init.MobEffects;
 import net.minecraft.init.SoundEvents;
 import net.minecraft.inventory.IInventory;
+import net.minecraft.item.ItemBow;
 import net.minecraft.item.ItemStack;
 import net.minecraft.server.integrated.IntegratedServer;
 import net.minecraft.src.Config;
@@ -68,6 +80,7 @@
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EntitySelectors;
 import net.minecraft.util.EnumFacing;
+import net.minecraft.util.EnumHand;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.MouseFilter;
 import net.minecraft.util.ReportedException;
@@ -78,7 +91,10 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.Vec3i;
+import net.minecraft.util.math.Vec4b;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.world.DimensionType;
 import net.minecraft.world.GameType;
@@ -89,13 +105,38 @@
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
+import org.lwjgl.opengl.GL30;
 import org.lwjgl.opengl.GLContext;
+import net.minecraft.client.renderer.GlStateManager.Color;
+import net.minecraft.client.renderer.GlStateManager.DestFactor;
+import net.minecraft.client.renderer.GlStateManager.SourceFactor;
+
 import org.lwjgl.util.glu.GLU;
 import org.lwjgl.util.glu.Project;
 import shadersmod.client.Shaders;
 import shadersmod.client.ShadersRender;
 
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.gson.JsonSyntaxException;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.provider.OpenVRPlayer;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.Utils;
+
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.EulerOrient;
+import de.fruitfly.ovr.structs.Quatf;
+import de.fruitfly.ovr.structs.Vector3f;
+import io.netty.handler.traffic.GlobalTrafficShapingHandler;
+import jopenvr.OpenVRUtil;
+import de.fruitfly.ovr.structs.Matrix4f;
+
+
+
 public class EntityRenderer implements IResourceManagerReloadListener
 {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -106,6 +147,45 @@
     /** Anaglyph field (0=R, 1=GB) */
     public static int anaglyphField;
 
+	/** MINECRIFT */
+	public static final float MAX_CROSSHAIR_DISTANCE = 64f;
+	public int renderpass = 0;
+	public EulerOrient currentEulerOrientDegrees = new EulerOrient();
+	public boolean sndSystemReflect = true;
+	public boolean guiYawOrientationResetRequested = false;
+	public boolean hudShowingLastFrame = false; //Used for detecting when UI is shown, fixing the guiYaw
+	public boolean guiScreenShowingThisFrame = false;
+	public boolean inGameMenuShowingLastFrame = false;
+	public boolean inWorldGuiScreenShowingThisFrame = false;
+	public Vec3d interpolatedPlayerPos = new Vec3d(0, 0, 0);
+    public Vec3d interPolatedRoomOrigin =new Vec3d(0, 0, 0);
+	public double cameraRoll;
+
+	public float crossX;
+	public float crossY;
+	public float crossZ;
+
+	public FloatBuffer[] eyeproj = new FloatBuffer[2]; //i dislike you.
+	
+	private boolean eyeCollision = false;
+	Block eyeCollisionBlock;
+	Vec3d eyeCollisionBlockPosLoc;
+	public float headCollisionThresholdDistance = 0.05f;
+	public float headCollisionDistance = -1f;
+	public Field _soundManagerSndSystemField = null;
+	public float clipDistance = 0f;
+	public float minClipDistance = 0.05f;
+	public boolean trySoundSystemReflect = true;
+	public float lookYawOffset = 0;
+	public float lookPitchOffset = 0;
+	public int callCount = 0;
+	public boolean warningsEnabled = false;
+	private Vec3d centerEyePosToCrossDirection;
+	public Vec3d crossVec;
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	public org.lwjgl.util.vector.Matrix4f thirdPassProjectionMatrix = new org.lwjgl.util.vector.Matrix4f();
+	/** END MINECRIFT */
+    
     /** A reference to the Minecraft object. */
     private final Minecraft mc;
     private final IResourceManager resourceManager;
@@ -199,10 +279,7 @@
     private float fogColor1;
     private int debugViewDirection;
     private boolean debugView;
-    private double cameraZoom = 1.0D;
-    private double cameraYaw;
-    private double cameraPitch;
-    private ShaderGroup theShaderGroup;
+    public ShaderGroup theShaderGroup;
     private static final ResourceLocation[] SHADERS_TEXTURES = new ResourceLocation[] {new ResourceLocation("shaders/post/notch.json"), new ResourceLocation("shaders/post/fxaa.json"), new ResourceLocation("shaders/post/art.json"), new ResourceLocation("shaders/post/bumpy.json"), new ResourceLocation("shaders/post/blobs2.json"), new ResourceLocation("shaders/post/pencil.json"), new ResourceLocation("shaders/post/color_convolve.json"), new ResourceLocation("shaders/post/deconverge.json"), new ResourceLocation("shaders/post/flip.json"), new ResourceLocation("shaders/post/invert.json"), new ResourceLocation("shaders/post/ntsc.json"), new ResourceLocation("shaders/post/outline.json"), new ResourceLocation("shaders/post/phosphor.json"), new ResourceLocation("shaders/post/scan_pincushion.json"), new ResourceLocation("shaders/post/sobel.json"), new ResourceLocation("shaders/post/bits.json"), new ResourceLocation("shaders/post/desaturate.json"), new ResourceLocation("shaders/post/green.json"), new ResourceLocation("shaders/post/blur.json"), new ResourceLocation("shaders/post/wobble.json"), new ResourceLocation("shaders/post/blobs.json"), new ResourceLocation("shaders/post/antialias.json"), new ResourceLocation("shaders/post/creeper.json"), new ResourceLocation("shaders/post/spider.json")};
     public static final int SHADER_COUNT = SHADERS_TEXTURES.length;
     private int shaderIndex;
@@ -212,7 +289,6 @@
     private World updatedWorld = null;
     private boolean showDebugInfo = false;
     public boolean fogStandard = false;
-    private float clipDistance = 128.0F;
     private long lastServerTime = 0L;
     private int lastServerTicks = 0;
     private int serverWaitTime = 0;
@@ -222,6 +298,11 @@
     private long lastErrorCheckTimeMs = 0L;
     private ShaderGroup[] fxaaShaders = new ShaderGroup[10];
 
+	Frustum currentFrustum = new Frustum();
+	
+	public boolean irpUpdatedThisFrame = false;
+    
+    
     public EntityRenderer(Minecraft mcIn, IResourceManager resourceManagerIn)
     {
         this.shaderIndex = SHADER_COUNT;
@@ -385,7 +466,7 @@
 
         Entity entity = this.mc.getRenderViewEntity();
         double d2 = entity.posX;
-        double d0 = entity.posY + (double)entity.getEyeHeight();
+        double d0 = entity.posY + entity.getEyeHeight();
         double d1 = entity.posZ;
         float f2 = this.mc.theWorld.getLightBrightness(new BlockPos(d2, d0, d1));
         float f3 = (float)this.mc.gameSettings.renderDistanceChunks / 16.0F;
@@ -435,112 +516,113 @@
      */
     public void getMouseOver(float partialTicks)
     {
-        Entity entity = this.mc.getRenderViewEntity();
-
-        if (entity != null && this.mc.theWorld != null)
-        {
-            this.mc.mcProfiler.startSection("pick");
-            this.mc.pointedEntity = null;
-            double d0 = (double)this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = entity.rayTrace(d0, partialTicks);
-            Vec3d vec3d = entity.getPositionEyes(partialTicks);
-            boolean flag = false;
-            int i = 3;
-            double d1 = d0;
-
-            if (this.mc.playerController.extendedReach())
-            {
-                d1 = 6.0D;
-                d0 = d1;
-            }
-            else if (d0 > 3.0D)
-            {
-                flag = true;
-            }
-
-            if (this.mc.objectMouseOver != null)
-            {
-                d1 = this.mc.objectMouseOver.hitVec.distanceTo(vec3d);
-            }
-
-            Vec3d vec3d1 = entity.getLook(partialTicks);
-            Vec3d vec3d2 = vec3d.addVector(vec3d1.xCoord * d0, vec3d1.yCoord * d0, vec3d1.zCoord * d0);
-            this.pointedEntity = null;
-            Vec3d vec3d3 = null;
-            float f = 1.0F;
-            List<Entity> list = this.mc.theWorld.getEntitiesInAABBexcluding(entity, entity.getEntityBoundingBox().addCoord(vec3d1.xCoord * d0, vec3d1.yCoord * d0, vec3d1.zCoord * d0).expand(1.0D, 1.0D, 1.0D), Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>()
-            {
-                public boolean apply(@Nullable Entity p_apply_1_)
-                {
-                    return p_apply_1_ != null && p_apply_1_.canBeCollidedWith();
-                }
-            }));
-            double d2 = d1;
-
-            for (int j = 0; j < list.size(); ++j)
-            {
-                Entity entity1 = (Entity)list.get(j);
-                AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().expandXyz((double)entity1.getCollisionBorderSize());
-                RayTraceResult raytraceresult = axisalignedbb.calculateIntercept(vec3d, vec3d2);
-
-                if (axisalignedbb.isVecInside(vec3d))
-                {
-                    if (d2 >= 0.0D)
-                    {
-                        this.pointedEntity = entity1;
-                        vec3d3 = raytraceresult == null ? vec3d : raytraceresult.hitVec;
-                        d2 = 0.0D;
-                    }
-                }
-                else if (raytraceresult != null)
-                {
-                    double d3 = vec3d.distanceTo(raytraceresult.hitVec);
-
-                    if (d3 < d2 || d2 == 0.0D)
-                    {
-                        boolean flag1 = false;
-
-                        if (Reflector.ForgeEntity_canRiderInteract.exists())
-                        {
-                            flag1 = Reflector.callBoolean(entity1, Reflector.ForgeEntity_canRiderInteract, new Object[0]);
-                        }
-
-                        if (!flag1 && entity1.getLowestRidingEntity() == entity.getLowestRidingEntity())
-                        {
-                            if (d2 == 0.0D)
-                            {
-                                this.pointedEntity = entity1;
-                                vec3d3 = raytraceresult.hitVec;
-                            }
-                        }
-                        else
-                        {
-                            this.pointedEntity = entity1;
-                            vec3d3 = raytraceresult.hitVec;
-                            d2 = d3;
-                        }
-                    }
-                }
-            }
-
-            if (this.pointedEntity != null && flag && vec3d.distanceTo(vec3d3) > 3.0D)
-            {
-                this.pointedEntity = null;
-                this.mc.objectMouseOver = new RayTraceResult(RayTraceResult.Type.MISS, vec3d3, (EnumFacing)null, new BlockPos(vec3d3));
-            }
-
-            if (this.pointedEntity != null && (d2 < d1 || this.mc.objectMouseOver == null))
-            {
-                this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, vec3d3);
-
-                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame)
-                {
-                    this.mc.pointedEntity = this.pointedEntity;
-                }
-            }
-
-            this.mc.mcProfiler.endSection();
-        }
+    	//NOPE!
+//        Entity entity = this.mc.getRenderViewEntity();
+//
+//        if (entity != null && this.mc.theWorld != null)
+//        {
+//            this.mc.mcProfiler.startSection("pick");
+//            this.mc.pointedEntity = null;
+//            double d0 = (double)this.mc.playerController.getBlockReachDistance();
+//            this.mc.objectMouseOver = entity.rayTrace(d0, partialTicks);
+//            Vec3d vec3d = entity.getPositionEyes(partialTicks);
+//            boolean flag = false;
+//            int i = 3;
+//            double d1 = d0;
+//
+//            if (this.mc.playerController.extendedReach())
+//            {
+//                d1 = 6.0D;
+//                d0 = d1;
+//            }
+//            else if (d0 > 3.0D)
+//            {
+//                flag = true;
+//            }
+//
+//            if (this.mc.objectMouseOver != null)
+//            {
+//                d1 = this.mc.objectMouseOver.hitVec.distanceTo(vec3d);
+//            }
+//
+//            Vec3d vec3d1 = entity.getLook(partialTicks);
+//            Vec3d vec3d2 = vec3d.addVector(vec3d1.xCoord * d0, vec3d1.yCoord * d0, vec3d1.zCoord * d0);
+//            this.pointedEntity = null;
+//            Vec3d vec3d3 = null;
+//            float f = 1.0F;
+//            List<Entity> list = this.mc.theWorld.getEntitiesInAABBexcluding(entity, entity.getEntityBoundingBox().addCoord(vec3d1.xCoord * d0, vec3d1.yCoord * d0, vec3d1.zCoord * d0).expand(1.0D, 1.0D, 1.0D), Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>()
+//            {
+//                public boolean apply(@Nullable Entity p_apply_1_)
+//                {
+//                    return p_apply_1_ != null && p_apply_1_.canBeCollidedWith();
+//                }
+//            }));
+//            double d2 = d1;
+//
+//            for (int j = 0; j < list.size(); ++j)
+//            {
+//                Entity entity1 = (Entity)list.get(j);
+//                AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().expandXyz((double)entity1.getCollisionBorderSize());
+//                RayTraceResult raytraceresult = axisalignedbb.calculateIntercept(vec3d, vec3d2);
+//
+//                if (axisalignedbb.isVecInside(vec3d))
+//                {
+//                    if (d2 >= 0.0D)
+//                    {
+//                        this.pointedEntity = entity1;
+//                        vec3d3 = raytraceresult == null ? vec3d : raytraceresult.hitVec;
+//                        d2 = 0.0D;
+//                    }
+//                }
+//                else if (raytraceresult != null)
+//                {
+//                    double d3 = vec3d.distanceTo(raytraceresult.hitVec);
+//
+//                    if (d3 < d2 || d2 == 0.0D)
+//                    {
+//                        boolean flag1 = false;
+//
+//                        if (Reflector.ForgeEntity_canRiderInteract.exists())
+//                        {
+//                            flag1 = Reflector.callBoolean(entity1, Reflector.ForgeEntity_canRiderInteract, new Object[0]);
+//                        }
+//
+//                        if (!flag1 && entity1.getLowestRidingEntity() == entity.getLowestRidingEntity())
+//                        {
+//                            if (d2 == 0.0D)
+//                            {
+//                                this.pointedEntity = entity1;
+//                                vec3d3 = raytraceresult.hitVec;
+//                            }
+//                        }
+//                        else
+//                        {
+//                            this.pointedEntity = entity1;
+//                            vec3d3 = raytraceresult.hitVec;
+//                            d2 = d3;
+//                        }
+//                    }
+//                }
+//            }
+//
+//            if (this.pointedEntity != null && flag && vec3d.distanceTo(vec3d3) > 3.0D)
+//            {
+//                this.pointedEntity = null;
+//                this.mc.objectMouseOver = new RayTraceResult(RayTraceResult.Type.MISS, vec3d3, (EnumFacing)null, new BlockPos(vec3d3));
+//            }
+//
+//            if (this.pointedEntity != null && (d2 < d1 || this.mc.objectMouseOver == null))
+//            {
+//                this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, vec3d3);
+//
+//                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame)
+//                {
+//                    this.mc.pointedEntity = this.pointedEntity;
+//                }
+//            }
+//
+//            this.mc.mcProfiler.endSection();
+//        }
     }
 
     /**
@@ -630,17 +712,18 @@
                 f /= (1.0F - 500.0F / (f1 + 500.0F)) * 2.0F + 1.0F;
             }
 
-            IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
-
-            if (iblockstate.getMaterial() == Material.WATER)
+            //IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
+            //VIVE DO BETTER           
+            if (itemRenderer.isInsideOfMaterial(getEyeRenderPos(mc.currentPass), Material.WATER))
             {
                 f = f * 60.0F / 70.0F;
             }
 
-            return Reflector.ForgeHooksClient_getFOVModifier.exists() ? Reflector.callFloat(Reflector.ForgeHooksClient_getFOVModifier, new Object[] {this, entity, iblockstate, Float.valueOf(partialTicks), Float.valueOf(f)}): f;
+            return f;
         }
     }
 
+    //unused
     private void hurtCameraEffect(float partialTicks)
     {
         if (this.mc.getRenderViewEntity() instanceof EntityLivingBase)
@@ -671,6 +754,7 @@
     /**
      * Updates the bobbing render effect of the player.
      */
+    //unused
     private void setupViewBobbing(float partialTicks)
     {
         if (this.mc.getRenderViewEntity() instanceof EntityPlayer)
@@ -695,35 +779,35 @@
         Entity entity = this.mc.getRenderViewEntity();
         float f = entity.getEyeHeight();
         double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)partialTicks;
-        double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)partialTicks + (double)f;
+        double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)partialTicks;// + (double)f;
         double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)partialTicks;
 
-        if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPlayerSleeping())
-        {
-            f = (float)((double)f + 1.0D);
-            GlStateManager.translate(0.0F, 0.3F, 0.0F);
-
-            if (!this.mc.gameSettings.debugCamEnable)
-            {
-                BlockPos blockpos = new BlockPos(entity);
-                IBlockState iblockstate = this.mc.theWorld.getBlockState(blockpos);
-                Block block = iblockstate.getBlock();
-
-                if (Reflector.ForgeHooksClient_orientBedCamera.exists())
-                {
-                    Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[] {this.mc.theWorld, blockpos, iblockstate, entity});
-                }
-                else if (block == Blocks.BED)
-                {
-                    int j = ((EnumFacing)iblockstate.getValue(BlockBed.FACING)).getHorizontalIndex();
-                    GlStateManager.rotate((float)(j * 90), 0.0F, 1.0F, 0.0F);
-                }
-
-                GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, -1.0F, 0.0F);
-                GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
-            }
-        }
-        else if (this.mc.gameSettings.thirdPersonView > 0)
+//        if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPlayerSleeping())
+//        {
+//            f = (float)((double)f + 1.0D);
+//            GlStateManager.translate(0.0F, 0.3F, 0.0F);
+//
+//            if (!this.mc.gameSettings.debugCamEnable)
+//            {
+//                BlockPos blockpos = new BlockPos(entity);
+//                IBlockState iblockstate = this.mc.theWorld.getBlockState(blockpos);
+//                Block block = iblockstate.getBlock();
+//
+//                if (Reflector.ForgeHooksClient_orientBedCamera.exists())
+//                {
+//                    Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[] {this.mc.theWorld, blockpos, iblockstate, entity});
+//                }
+//                else if (block == Blocks.BED)
+//                {
+//                    int j = ((EnumFacing)iblockstate.getValue(BlockBed.FACING)).getHorizontalIndex();
+//                    GlStateManager.rotate((float)(j * 90), 0.0F, 1.0F, 0.0F);
+//                }
+//
+//                GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, -1.0F, 0.0F);
+//                GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
+//            }
+//       }
+        if (this.mc.gameSettings.thirdPersonView > 0)
         {
             double d3 = (double)(this.thirdPersonDistancePrev + (4.0F - this.thirdPersonDistancePrev) * partialTicks);
 
@@ -733,8 +817,8 @@
             }
             else
             {
-                float f1 = entity.rotationYaw;
-                float f2 = entity.rotationPitch;
+                float f1 = rveyaw;// entity.rotationYaw;
+                float f2 = rvepitch;// entity.rotationPitch;
 
                 if (this.mc.gameSettings.thirdPersonView == 2)
                 {
@@ -753,7 +837,12 @@
                     f3 = f3 * 0.1F;
                     f4 = f4 * 0.1F;
                     f5 = f5 * 0.1F;
-                    RayTraceResult raytraceresult = this.mc.theWorld.rayTraceBlocks(new Vec3d(d0 + (double)f3, d1 + (double)f4, d2 + (double)f5), new Vec3d(d0 - d4 + (double)f3 + (double)f5, d1 - d6 + (double)f4, d2 - d5 + (double)f5));
+                    
+                	Vec3d pos = getEyeRenderPos(mc.currentPass);
+                    
+                    RayTraceResult raytraceresult = this.mc.theWorld.rayTraceBlocks(
+                    		new Vec3d(pos.xCoord + (double)f3, pos.yCoord + (double)f4, pos.zCoord + (double)f5),
+                    		new Vec3d(pos.xCoord - d4 + (double)f3 + (double)f5, pos.yCoord - d6 + (double)f4, pos.zCoord - d5 + (double)f5));
 
                     if (raytraceresult != null)
                     {
@@ -771,253 +860,238 @@
                     GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
                 }
 
-                GlStateManager.rotate(entity.rotationPitch - f2, 1.0F, 0.0F, 0.0F);
-                GlStateManager.rotate(entity.rotationYaw - f1, 0.0F, 1.0F, 0.0F);
+                GlStateManager.rotate(rvepitch - f2, 1.0F, 0.0F, 0.0F);
+                GlStateManager.rotate(rveyaw - f1, 0.0F, 1.0F, 0.0F);
                 GlStateManager.translate(0.0F, 0.0F, (float)(-d3));
-                GlStateManager.rotate(f1 - entity.rotationYaw, 0.0F, 1.0F, 0.0F);
-                GlStateManager.rotate(f2 - entity.rotationPitch, 1.0F, 0.0F, 0.0F);
-            }
-        }
-        else
-        {
-            GlStateManager.translate(0.0F, 0.0F, 0.05F);
-        }
-
-        if (Reflector.EntityViewRenderEvent_CameraSetup_Constructor.exists())
-        {
-            if (!this.mc.gameSettings.debugCamEnable)
-            {
-                float f6 = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F;
-                float f7 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
-                float f8 = 0.0F;
-
-                if (entity instanceof EntityAnimal)
-                {
-                    EntityAnimal entityanimal1 = (EntityAnimal)entity;
-                    f6 = entityanimal1.prevRotationYawHead + (entityanimal1.rotationYawHead - entityanimal1.prevRotationYawHead) * partialTicks + 180.0F;
-                }
-
-                IBlockState iblockstate1 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
-                Object object = Reflector.newInstance(Reflector.EntityViewRenderEvent_CameraSetup_Constructor, new Object[] {this, entity, iblockstate1, Float.valueOf(partialTicks), Float.valueOf(f6), Float.valueOf(f7), Float.valueOf(f8)});
-                Reflector.postForgeBusEvent(object);
-                f8 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getRoll, new Object[0]);
-                f7 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getPitch, new Object[0]);
-                f6 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getYaw, new Object[0]);
-                GlStateManager.rotate(f8, 0.0F, 0.0F, 1.0F);
-                GlStateManager.rotate(f7, 1.0F, 0.0F, 0.0F);
-                GlStateManager.rotate(f6, 0.0F, 1.0F, 0.0F);
-            }
-        }
-        else if (!this.mc.gameSettings.debugCamEnable)
-        {
-            GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, 1.0F, 0.0F, 0.0F);
-
-            if (entity instanceof EntityAnimal)
-            {
-                EntityAnimal entityanimal = (EntityAnimal)entity;
-                GlStateManager.rotate(entityanimal.prevRotationYawHead + (entityanimal.rotationYawHead - entityanimal.prevRotationYawHead) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
-            }
-            else
-            {
-                GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
-            }
-        }
+                GlStateManager.rotate(f1 - rveyaw, 0.0F, 1.0F, 0.0F);
+                GlStateManager.rotate(f2 - rvepitch, 1.0F, 0.0F, 0.0F);
+                
+                GlStateManager.translate(0.0F, -f, 0.0F);
+
+            }
+        }
+		else if(mc.currentPass == renderPass.Third){
+			
+			GL11.glRotatef(mc.vrSettings.vrFixedCamrotPitch, 1.0F, 0.0F, 0.0F);
+			//idk why its like that
+			GL11.glRotatef(180+mc.vrSettings.vrFixedCamrotYaw - mc.vrSettings.vrWorldRotation, 0.0F, 1.0F, 0.0F);
+			GL11.glRotatef(mc.vrSettings.vrFixedCamrotRoll, 0.0F, 0.0F, 1.0F);
+			
+		} else 	{
+			/** MINECRIFT */    
+
+			 // do proper 1st person camera orientation.
+			
+			GlStateManager.multMatrix(mc.roomScale.getHMDMatrix_World());
+						
+			//dont do depth here. Do later. cause reasons.
+		}
+
+        
+//        if (Reflector.EntityViewRenderEvent_CameraSetup_Constructor.exists())
+//        {
+//            if (!this.mc.gameSettings.debugCamEnable)
+//            {
+//                float f6 = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F;
+//                float f7 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
+//                float f8 = 0.0F;
+//
+//                if (entity instanceof EntityAnimal)
+//                {
+//                    EntityAnimal entityanimal1 = (EntityAnimal)entity;
+//                    f6 = entityanimal1.prevRotationYawHead + (entityanimal1.rotationYawHead - entityanimal1.prevRotationYawHead) * partialTicks + 180.0F;
+//                }
+//
+//                IBlockState iblockstate1 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
+//                Object object = Reflector.newInstance(Reflector.EntityViewRenderEvent_CameraSetup_Constructor, new Object[] {this, entity, iblockstate1, Float.valueOf(partialTicks), Float.valueOf(f6), Float.valueOf(f7), Float.valueOf(f8)});
+//                Reflector.postForgeBusEvent(object);
+//                f8 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getRoll, new Object[0]);
+//                f7 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getPitch, new Object[0]);
+//                f6 = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_CameraSetup_getYaw, new Object[0]);
+//                GlStateManager.rotate(f8, 0.0F, 0.0F, 1.0F);
+//                GlStateManager.rotate(f7, 1.0F, 0.0F, 0.0F);
+//                GlStateManager.rotate(f6, 0.0F, 1.0F, 0.0F);
+//            }
+//        }
+//        else if (!this.mc.gameSettings.debugCamEnable)
+//        {
+//            GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, 1.0F, 0.0F, 0.0F);
+//
+//            if (entity instanceof EntityAnimal)
+//            {
+//                EntityAnimal entityanimal = (EntityAnimal)entity;
+//                GlStateManager.rotate(entityanimal.prevRotationYawHead + (entityanimal.rotationYawHead - entityanimal.prevRotationYawHead) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
+//            }
+//            else
+//            {
+//                GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
+//            }
+//        }
 
-        GlStateManager.translate(0.0F, -f, 0.0F);
+       // GlStateManager.translate(0.0F, -f, 0.0F);
         d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)partialTicks;
-        d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)partialTicks + (double)f;
+        d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)partialTicks;
         d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)partialTicks;
         this.cloudFog = this.mc.renderGlobal.hasCloudFog(d0, d1, d2, partialTicks);
     }
 
+    //do tis separte to hide it from shadersmod shadow pass, also do the sky.
+    public void applyCameraDepth(boolean reverse){
+			// Position
+    	//backwards in 1.10
+			Vec3d campos =  this.getEyeRenderPos(mc.currentPass).subtract(mc.getRenderViewEntity().getPositionVector());
+			float x = (float) (campos.xCoord );
+			float y = (float) (campos.yCoord);
+			float z = (float) (campos.zCoord );
+			int i = 1;
+			if(reverse) i = -1;
+			//This is just for depth.
+			GlStateManager.translate(-x*i, -y*i, -z*i);	
+    }
+    
     /**
      * sets up projection, view effects, camera position/rotation
      */
     public void setupCameraTransform(float partialTicks, int pass)
     {
-        this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
-
-        if (Config.isFogFancy())
-        {
-            this.farPlaneDistance *= 0.95F;
-        }
-
-        if (Config.isFogFast())
-        {
-            this.farPlaneDistance *= 0.83F;
-        }
-
-        GlStateManager.matrixMode(5889);
-        GlStateManager.loadIdentity();
-        float f = 0.07F;
-
-        if (this.mc.gameSettings.anaglyph)
-        {
-            GlStateManager.translate((float)(-(pass * 2 - 1)) * 0.07F, 0.0F, 0.0F);
-        }
-
-        this.clipDistance = this.farPlaneDistance * 2.0F;
-
-        if (this.clipDistance < 173.0F)
-        {
-            this.clipDistance = 173.0F;
-        }
-
-        if (this.mc.theWorld.provider.getDimensionType() == DimensionType.THE_END)
-        {
-            this.clipDistance = 256.0F;
-        }
-
-        if (this.cameraZoom != 1.0D)
-        {
-            GlStateManager.translate((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
-            GlStateManager.scale(this.cameraZoom, this.cameraZoom, 1.0D);
-        }
-
-        Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
-        GlStateManager.matrixMode(5888);
-        GlStateManager.loadIdentity();
-
-        if (this.mc.gameSettings.anaglyph)
-        {
-            GlStateManager.translate((float)(pass * 2 - 1) * 0.1F, 0.0F, 0.0F);
-        }
-
-        this.hurtCameraEffect(partialTicks);
-
-        if (this.mc.gameSettings.viewBobbing)
-        {
-            this.setupViewBobbing(partialTicks);
-        }
-
-        float f1 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * partialTicks;
+		/** MINECRIFT */
 
-        if (f1 > 0.0F)
-        {
-            int i = 20;
+    	GlStateManager.matrixMode(GL11.GL_PROJECTION);
+    	GlStateManager.loadIdentity();
+    	
+		float var3 = 0.07F;
+
+
+		if (this.mc.stereoProvider.isStereo() && mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center)
+		{
+			int i = mc.currentPass.value();
+			if(i>1) i = 0;
+			GlStateManager.multMatrix(mc.eyeproj[i]);
+		}
+		else
+		{
+			Project.gluPerspective(this.mc.gameSettings.fovSetting, this.mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY ? this.mc.vrSettings.mixedRealityAspectRatio : (float)this.mc.displayWidth / (float)this.mc.displayHeight, minClipDistance, clipDistance);
+		}
+		
+		if (mc.currentPass == renderPass.Third) {
+			GL11.glGetFloat(GL11.GL_PROJECTION_MATRIX, matrixBuffer);
+			matrixBuffer.rewind();
+			this.thirdPassProjectionMatrix.load(matrixBuffer);
+			matrixBuffer.rewind();
+		}
+
+		float var4;
+
+    	GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+    	GlStateManager.loadIdentity();
+    	
+		var4 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * partialTicks;
+
+		if (var4 > 0.0F && !this.mc.vrSettings.debugPos)
+		{
+			byte var7 = 20;
 
             if (this.mc.thePlayer.isPotionActive(MobEffects.NAUSEA))
-            {
-                i = 7;
-            }
-
-            float f2 = 5.0F / (f1 * f1 + 5.0F) - f1 * 0.04F;
-            f2 = f2 * f2;
-            GlStateManager.rotate(((float)this.rendererUpdateCount + partialTicks) * (float)i, 0.0F, 1.0F, 1.0F);
-            GlStateManager.scale(1.0F / f2, 1.0F, 1.0F);
-            GlStateManager.rotate(-((float)this.rendererUpdateCount + partialTicks) * (float)i, 0.0F, 1.0F, 1.0F);
-        }
-
-        this.orientCamera(partialTicks);
-
-        if (this.debugView)
-        {
-            switch (this.debugViewDirection)
-            {
-                case 0:
-                    GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
-                    break;
-
-                case 1:
-                    GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
-                    break;
-
-                case 2:
-                    GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
-                    break;
-
-                case 3:
-                    GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
-                    break;
-
-                case 4:
-                    GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
-            }
-        }
-    }
+			{
+				var7 = 7;
+			}
+
+			float var6 = 5.0F / (var4 * var4 + 5.0F) - var4 * 0.04F;
+			var6 *= var6;
+			GL11.glRotatef(((float)this.rendererUpdateCount + partialTicks) * (float)var7, 0.0F, 1.0F, 1.0F);
+			GL11.glScalef(1.0F / var6, 1.0F, 1.0F);
+			GL11.glRotatef(-((float)this.rendererUpdateCount + partialTicks) * (float)var7, 0.0F, 1.0F, 1.0F);
+		}
+
+		this.orientCamera(partialTicks);
+
+		if (this.debugViewDirection > 0 && !this.mc.vrSettings.debugPos)
+		{
+			int var71 = this.debugViewDirection - 1;
+
+			if (var71 == 1)
+			{
+				GL11.glRotatef(90.0F, 0.0F, 1.0F, 0.0F);
+			}
+
+			if (var71 == 2)
+			{
+				GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
+			}
+
+			if (var71 == 3)
+			{
+				GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
+			}
+
+			if (var71 == 4)
+			{
+				GL11.glRotatef(90.0F, 1.0F, 0.0F, 0.0F);
+			}
+
+			if (var71 == 5)
+			{
+				GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
+			}
+		}
+		/** END MINECRIFT */
+	}
 
     /**
      * Render player hand
      */
     public void renderHand(float partialTicks, int pass)
     {
-        if (!this.debugView)
-        {
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            float f = 0.07F;
-
-            if (this.mc.gameSettings.anaglyph)
-            {
-                GlStateManager.translate((float)(-(pass * 2 - 1)) * 0.07F, 0.0F, 0.0F);
-            }
-
-            if (Config.isShaders())
-            {
-                Shaders.applyHandDepth();
-            }
-
-            Project.gluPerspective(this.getFOVModifier(partialTicks, false), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
-            GlStateManager.matrixMode(5888);
-            GlStateManager.loadIdentity();
-
-            if (this.mc.gameSettings.anaglyph)
-            {
-                GlStateManager.translate((float)(pass * 2 - 1) * 0.1F, 0.0F, 0.0F);
-            }
-
-            boolean flag = false;
-
-            if (!Config.isShaders() || !Shaders.isHandRendered)
-            {
-                GlStateManager.pushMatrix();
-                this.hurtCameraEffect(partialTicks);
-
-                if (this.mc.gameSettings.viewBobbing)
-                {
-                    this.setupViewBobbing(partialTicks);
-                }
-
-                flag = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
-
-                if (this.mc.gameSettings.thirdPersonView == 0 && !flag && !this.mc.gameSettings.hideGUI && !this.mc.playerController.isSpectator())
-                {
-                    this.enableLightmap();
-
-                    if (Config.isShaders())
-                    {
-                        ShadersRender.renderItemFP(this.itemRenderer, partialTicks);
-                    }
-                    else
-                    {
-                        this.itemRenderer.renderItemInFirstPerson(partialTicks);
-                    }
-
-                    this.disableLightmap();
-                }
-
-                GlStateManager.popMatrix();
-            }
-
-            if (Config.isShaders() && !Shaders.isCompositeRendered)
-            {
-                return;
-            }
-
-            this.disableLightmap();
-
-            if (this.mc.gameSettings.thirdPersonView == 0 && !flag)
-            {
-                this.itemRenderer.renderOverlays(partialTicks);
-                this.hurtCameraEffect(partialTicks);
-            }
-
-            if (this.mc.gameSettings.viewBobbing)
-            {
-                this.setupViewBobbing(partialTicks);
-            }
-        }
-    }
+		boolean shadersMod = Config.isShaders();
+		
+		if(shadersMod){
+			//Shaders.readCenterDepth();
+			Shaders.beginHand();
+		}else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPushMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+		}
+			
+			//from player face to HMD
+			setupCameraTransform(partialTicks, pass);
+			applyCameraDepth(false);
+			if (this.mc.gameSettings.thirdPersonView == 0) 
+			{
+	
+				// VIVE START - from HMD to controller
+				SetupRenderingAtController(0);
+	
+				ItemStack item = mc.thePlayer.getHeldItemMainhand();
+	
+				if(item != null && item.getItem()instanceof ItemBow){
+					int c = 0;
+					if (mc.vrSettings.vrReverseShootingEye) c = 1;
+					
+					ItemStack ammo = ((ItemBow)item.getItem()).findAmmoItemStack(mc.thePlayer);
+					if (ammo !=null  && !mc.bowTracker.isNotched()) { //render the arrow in right, left hand will check for and render bow.
+						itemRenderer.renderItemInFirstPerson(mc.thePlayer, partialTicks, 0, EnumHand.MAIN_HAND, mc.thePlayer.getSwingProgress(partialTicks), ammo, 0);
+					} else {
+						itemRenderer.renderItemInFirstPerson(mc.thePlayer, partialTicks, 0, EnumHand.MAIN_HAND, mc.thePlayer.getSwingProgress(partialTicks), null, 0);
+					}
+					
+				}else {
+					itemRenderer.renderItemInFirstPerson(mc.thePlayer, partialTicks, 0, EnumHand.MAIN_HAND, mc.thePlayer.getSwingProgress(partialTicks), item, 0);
+				}
+			}
+
+			
+		if(shadersMod)
+			Shaders.endHand();
+		else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPopMatrix();
+		}
+		
+	}
 
     public void disableLightmap()
     {
@@ -1034,12 +1108,12 @@
     public void enableLightmap()
     {
         GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
-        GlStateManager.matrixMode(5890);
+        GlStateManager.matrixMode(GL11.GL_TEXTURE);
         GlStateManager.loadIdentity();
         float f = 0.00390625F;
         GlStateManager.scale(0.00390625F, 0.00390625F, 0.00390625F);
         GlStateManager.translate(8.0F, 8.0F, 8.0F);
-        GlStateManager.matrixMode(5888);
+        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
         this.mc.getTextureManager().bindTexture(this.locationLightMap);
         GlStateManager.glTexParameteri(3553, 10241, 9729);
         GlStateManager.glTexParameteri(3553, 10240, 9729);
@@ -1221,197 +1295,109 @@
         return i > 200 ? 1.0F : 0.7F + MathHelper.sin(((float)i - partialTicks) * (float)Math.PI * 0.2F) * 0.3F;
     }
 
-    public void updateCameraAndRender(float partialTicks, long nanoTime)
-    {
-        this.frameInit();
-        boolean flag = Display.isActive();
-
-        if (!flag && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1)))
-        {
-            if (Minecraft.getSystemTime() - this.prevFrameTime > 500L)
-            {
-                this.mc.displayInGameMenu();
-            }
-        }
-        else
-        {
-            this.prevFrameTime = Minecraft.getSystemTime();
-        }
-
-        this.mc.mcProfiler.startSection("mouse");
-
-        if (flag && Minecraft.IS_RUNNING_ON_MAC && this.mc.inGameHasFocus && !Mouse.isInsideWindow())
-        {
-            Mouse.setGrabbed(false);
-            Mouse.setCursorPosition(Display.getWidth() / 2, Display.getHeight() / 2 - 20);
-            Mouse.setGrabbed(true);
-        }
-
-        if (this.mc.inGameHasFocus && flag)
-        {
-            this.mc.mouseHelper.mouseXYChange();
-            float f = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-            float f1 = f * f * f * 8.0F;
-            float f2 = (float)this.mc.mouseHelper.deltaX * f1;
-            float f3 = (float)this.mc.mouseHelper.deltaY * f1;
-            int i = 1;
-
-            if (this.mc.gameSettings.invertMouse)
-            {
-                i = -1;
-            }
+    public void updateCameraAndRender(float par1)
+	{// called each eye
 
-            if (this.mc.gameSettings.smoothCamera)
-            {
-                this.smoothCamYaw += f2;
-                this.smoothCamPitch += f3;
-                float f4 = partialTicks - this.smoothCamPartialTicks;
-                this.smoothCamPartialTicks = partialTicks;
-                f2 = this.smoothCamFilterX * f4;
-                f3 = this.smoothCamFilterY * f4;
-                this.mc.thePlayer.setAngles(f2, f3 * (float)i);
-            }
-            else
-            {
-                this.smoothCamYaw = 0.0F;
-                this.smoothCamPitch = 0.0F;
-                this.mc.thePlayer.setAngles(f2, f3 * (float)i);
-            }
-        }
+		if(mc.currentPass == renderPass.Left) //contains all the stuff that was in this method that only needs to be called once per frame.
+			updateCameraAndRender_OnePass(par1);
 
-        this.mc.mcProfiler.endSection();
+		if (!this.mc.skipRenderWorld)
+		{//RENDER WORLD
+			/** MINECRIFT */
+			anaglyphEnable = false;
+			/** END MINECRIFT */
+			
+			if (this.mc.theWorld != null && !(mc.currentScreen instanceof GuiWinGame))
+			{
+				
+				this.mc.mcProfiler.startSection("renderWorld");
+					this.renderWorld(par1, 0L);
+				this.mc.mcProfiler.endSection();
+				
+				if (OpenGlHelper.shadersSupported)
+				{
+					if (this.theShaderGroup != null)
+					{
+						GL11.glMatrixMode(GL11.GL_TEXTURE);
+						GL11.glPushMatrix();
+							GL11.glLoadIdentity();
+							this.theShaderGroup.loadShaderGroup(par1);
+						GL11.glPopMatrix();
+						/** MINECRIFT */
+						GL11.glMatrixMode(GL11.GL_MODELVIEW);
+						/** END MINECRIFT */
+					}
+					this.mc.getFramebuffer().bindFramebuffer(true);
+				}
+
+				this.renderEndNanoTime = System.nanoTime();
+				
+				/** MINECRIFT */
+				if (!this.mc.stereoProvider.isStereo()) //TODO wtf is all this....
+				{
+					if (!this.mc.vrSettings.hideGui || this.mc.currentScreen != null)
+					{
+						GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
+						boolean var12 = this.mc.gameSettings.fancyGraphics;
+
+						if (!Config.isVignetteEnabled())
+						{
+							this.mc.gameSettings.fancyGraphics = false;
+						}
+						
+						//why was this called twice per loop??
+					//	this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var161, var171);
+						
+						this.mc.gameSettings.fancyGraphics = var12;
+
+					}
+				}
+				/** END MINECRIFT */
+			}//END RENDER WORLD
+			
+	
+			renderFadeEffects();
+
+			GlStateManager.disableBlend();
+			GlStateManager.disableAlpha();
+			GlStateManager.enableDepth();
+			GlStateManager.enableTexture2D();
+			
+			if (this.mc.theWorld == null || mc.currentScreen instanceof GuiWinGame) {
+				this.mc.mcProfiler.startSection("renderGui");
+					GL11.glDisable(GL11.GL_STENCIL_TEST);
+					if(!mc.bowTracker.isDrawing) renderGuiLayer(par1);
+				this.mc.mcProfiler.endSection();
+			}
+			
+			
+			if((mc.theWorld == null || mc.currentScreen instanceof GuiWinGame) && (mc.currentPass != renderPass.Third || mc.vrSettings.mixedRealityRenderHands)){
+				// VIVE START - render controllers in main menu
+				this.mc.mcProfiler.startSection("mainMenuHands");
+					renderMainMenuHands();
+				this.mc.mcProfiler.endSection();
+			}
+			
+			
+			// Minecrift - handle notification text
+			handleNotificationText();
+
+			this.renderEndNanoTime = System.nanoTime();
+			
+		}
+
+	}
+    
+    
+    
+    private void updateCameraAndRender_OnePass(float par1) {
+
+    	this.frameInit();
+		
+		Config.checkDisplayMode();
 
-        if (!this.mc.skipRenderWorld)
-        {
-            anaglyphEnable = this.mc.gameSettings.anaglyph;
-            final ScaledResolution scaledresolution = new ScaledResolution(this.mc);
-            int i1 = scaledresolution.getScaledWidth();
-            int j1 = scaledresolution.getScaledHeight();
-            final int k1 = Mouse.getX() * i1 / this.mc.displayWidth;
-            final int l1 = j1 - Mouse.getY() * j1 / this.mc.displayHeight - 1;
-            int i2 = this.mc.gameSettings.limitFramerate;
-
-            if (this.mc.theWorld == null)
-            {
-                GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-                GlStateManager.matrixMode(5889);
-                GlStateManager.loadIdentity();
-                GlStateManager.matrixMode(5888);
-                GlStateManager.loadIdentity();
-                this.setupOverlayRendering();
-                this.renderEndNanoTime = System.nanoTime();
-            }
-            else
-            {
-                this.mc.mcProfiler.startSection("level");
-                int j = Math.min(Minecraft.getDebugFPS(), i2);
-                j = Math.max(j, 60);
-                long k = System.nanoTime() - nanoTime;
-                long l = Math.max((long)(1000000000 / j / 4) - k, 0L);
-                this.renderWorld(partialTicks, System.nanoTime() + l);
-
-                if (this.mc.isSingleplayer() && this.timeWorldIcon < Minecraft.getSystemTime() - 1000L)
-                {
-                    this.timeWorldIcon = Minecraft.getSystemTime();
-
-                    if (!this.mc.getIntegratedServer().isWorldIconSet())
-                    {
-                        this.createWorldIcon();
-                    }
-                }
-
-                if (OpenGlHelper.shadersSupported)
-                {
-                    this.mc.renderGlobal.renderEntityOutlineFramebuffer();
-
-                    if (this.theShaderGroup != null && this.useShader)
-                    {
-                        GlStateManager.matrixMode(5890);
-                        GlStateManager.pushMatrix();
-                        GlStateManager.loadIdentity();
-                        this.theShaderGroup.loadShaderGroup(partialTicks);
-                        GlStateManager.popMatrix();
-                    }
-
-                    this.mc.getFramebuffer().bindFramebuffer(true);
-                }
-
-                this.renderEndNanoTime = System.nanoTime();
-                this.mc.mcProfiler.endStartSection("gui");
-
-                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
-                {
-                    GlStateManager.alphaFunc(516, 0.1F);
-                    this.mc.ingameGUI.renderGameOverlay(partialTicks);
-
-                    if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo)
-                    {
-                        Config.drawFps();
-                    }
-
-                    if (this.mc.gameSettings.showDebugInfo)
-                    {
-                        Lagometer.showLagometer(scaledresolution);
-                    }
-                }
-
-                this.mc.mcProfiler.endSection();
-            }
-
-            if (this.mc.currentScreen != null)
-            {
-                GlStateManager.clear(256);
-
-                try
-                {
-                    if (Reflector.ForgeHooksClient_drawScreen.exists())
-                    {
-                        Reflector.callVoid(Reflector.ForgeHooksClient_drawScreen, new Object[] {this.mc.currentScreen, Integer.valueOf(k1), Integer.valueOf(l1), Float.valueOf(partialTicks)});
-                    }
-                    else
-                    {
-                        this.mc.currentScreen.drawScreen(k1, l1, partialTicks);
-                    }
-                }
-                catch (Throwable throwable)
-                {
-                    CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Rendering screen");
-                    CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
-                    crashreportcategory.setDetail("Screen name", new ICrashReportDetail<String>()
-                    {
-                        public String call() throws Exception
-                        {
-                            return EntityRenderer.this.mc.currentScreen.getClass().getCanonicalName();
-                        }
-                    });
-                    crashreportcategory.setDetail("Mouse location", new ICrashReportDetail<String>()
-                    {
-                        public String call() throws Exception
-                        {
-                            return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[] {Integer.valueOf(k1), Integer.valueOf(l1), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
-                        }
-                    });
-                    crashreportcategory.setDetail("Screen size", new ICrashReportDetail<String>()
-                    {
-                        public String call() throws Exception
-                        {
-                            return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[] {Integer.valueOf(scaledresolution.getScaledWidth()), Integer.valueOf(scaledresolution.getScaledHeight()), Integer.valueOf(EntityRenderer.this.mc.displayWidth), Integer.valueOf(EntityRenderer.this.mc.displayHeight), Integer.valueOf(scaledresolution.getScaleFactor())});
-                        }
-                    });
-                    throw new ReportedException(crashreport);
-                }
-            }
-        }
-
-        this.frameFinish();
-        this.waitForServerThread();
-        Lagometer.updateLagometer();
-
-        if (this.mc.gameSettings.ofProfiler)
-        {
-            this.mc.gameSettings.showDebugProfilerChart = true;
-        }
-    }
+	}
+    
 
     private void createWorldIcon()
     {
@@ -1461,6 +1447,9 @@
         }
         else
         {
+        	
+			if (mc.vrPlayer.movementTeleportProgress>0.0f)	return false;		// VIVE  - don't render outline if aiming a teleport
+        	
             Entity entity = this.mc.getRenderViewEntity();
             boolean flag = entity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
 
@@ -1491,404 +1480,510 @@
 
     public void renderWorld(float partialTicks, long finishTimeNano)
     {
-        this.updateLightmap(partialTicks);
-
+	    int pass = 2;
         if (this.mc.getRenderViewEntity() == null)
         {
             this.mc.setRenderViewEntity(this.mc.thePlayer);
         }
-
-        this.getMouseOver(partialTicks);
-
+    	EntityLivingBase player = (EntityLivingBase) this.mc.getRenderViewEntity();
+    	
+		/** MINECRIFT */
+		interpolatedPlayerPos = new Vec3d(player.lastTickPosX + (player.posX - player.lastTickPosX) * (double)partialTicks,
+		player.lastTickPosY + (player.posY - player.lastTickPosY) * (double)partialTicks,
+		player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * (double)partialTicks);
+
+		if(irpUpdatedThisFrame){
+			interPolatedRoomOrigin = new Vec3d(
+			mc.vrPlayer.roomOrigin.xCoord,	
+			mc.vrPlayer.roomOrigin.yCoord,		
+			mc.vrPlayer.roomOrigin.zCoord);
+		}else{
+			interPolatedRoomOrigin = new Vec3d(
+			mc.vrPlayer.lastroomOrigin.xCoord + (mc.vrPlayer.roomOrigin.xCoord - mc.vrPlayer.lastroomOrigin.xCoord ) * (double)partialTicks,
+			mc.vrPlayer.lastroomOrigin.yCoord + (mc.vrPlayer.roomOrigin.yCoord - mc.vrPlayer.lastroomOrigin.yCoord ) * (double)partialTicks,		
+			mc.vrPlayer.lastroomOrigin.zCoord + (mc.vrPlayer.roomOrigin.zCoord - mc.vrPlayer.lastroomOrigin.zCoord ) * (double)partialTicks);
+		}
+	        
+		cacheRVEPos((EntityLivingBase) mc.getRenderViewEntity());
+		
+		Vec3d f, g; 
+		if(mc.currentPass == renderPass.Third)
+			f = getEyeRenderPos(renderPass.Third);
+		else{
+			f = getEyeRenderPos(renderPass.Center);
+		}
+		
+		player.posX = f.xCoord;
+		player.posY = f.yCoord;
+		player.posZ = f.zCoord;
+		player.lastTickPosX = f.xCoord;
+		player.lastTickPosY = f.yCoord;
+		player.lastTickPosZ = f.zCoord;
+		player.prevPosX = f.xCoord;
+		player.prevPosY = f.yCoord;
+		player.prevPosZ = f.zCoord;
+		player.rotationPitch =player.prevRotationPitch = - mc.roomScale.getHMDPitch_World();
+		player.prevRotationYawHead	= player.prevRotationYaw  = player.rotationYaw = player.rotationYawHead = mc.roomScale.getHMDYaw_World();
+		((EntityPlayerSP)player).overrideEyeHeight = true;
+		
+		this.mc.mcProfiler.startSection("lightTex");
+		
+	        this.updateLightmap(partialTicks);
+	        
+         this.getMouseOver(partialTicks);
+
+		this.mc.mcProfiler.endStartSection("getPointedBlock");
+
+			if( this.mc.currentScreen == null )
+			{
+				if(mc.currentPass == renderPass.Left)	
+					getPointedBlock(partialTicks);   
+					
+					// Set up crosshair position
+					float SLIGHTLY_CLOSER = 0.001f;
+					Vec3d eye = getEyeRenderPos(mc.currentPass);
+					Vec3d pos = mc.roomScale.getHMDPos_World();
+					Vec3d centerEyePosToCrossDirection = eye.subtract(crossVec).normalize();   // VIVE use camerapos
+					crossX = (float)(crossVec.xCoord - (centerEyePosToCrossDirection.xCoord*SLIGHTLY_CLOSER) -  pos.xCoord);
+					crossY = (float)(crossVec.yCoord - (centerEyePosToCrossDirection.yCoord*SLIGHTLY_CLOSER) -  pos.yCoord);
+					crossZ = (float)(crossVec.zCoord - (centerEyePosToCrossDirection.zCoord*SLIGHTLY_CLOSER) -  pos.zCoord);
+				// information for the entire frame, not individual eye pos camRelX, Y, Z
+			}
+       
         if (Config.isShaders())
         {
-            Shaders.beginRender(this.mc, partialTicks, finishTimeNano);
+        	this.mc.mcProfiler.endStartSection("shadersModBeginRender");	
+        		Shaders.beginRender(this.mc, partialTicks, finishTimeNano);
         }
 
+               
         GlStateManager.enableDepth();
         GlStateManager.enableAlpha();
         GlStateManager.alphaFunc(516, 0.1F);
-        this.mc.mcProfiler.startSection("center");
-
-        if (this.mc.gameSettings.anaglyph)
-        {
-            anaglyphField = 0;
-            GlStateManager.colorMask(false, true, true, false);
-            this.renderWorldPass(0, partialTicks, finishTimeNano);
-            anaglyphField = 1;
-            GlStateManager.colorMask(true, false, false, false);
-            this.renderWorldPass(1, partialTicks, finishTimeNano);
-            GlStateManager.colorMask(true, true, true, false);
-        }
-        else
-        {
-            this.renderWorldPass(2, partialTicks, finishTimeNano);
-        }
+        this.mc.gameSettings.anaglyph = false; //just no.
+        
 
-        this.mc.mcProfiler.endSection();
-    }
 
-    private void renderWorldPass(int pass, float partialTicks, long finishTimeNano)
-    {
-        boolean flag = Config.isShaders();
+        boolean shadersMod = Config.isShaders();
 
-        if (flag)
+        if (shadersMod)
         {
             Shaders.beginRenderPass(pass, partialTicks, finishTimeNano);
         }
 
         RenderGlobal renderglobal = this.mc.renderGlobal;
         ParticleManager particlemanager = this.mc.effectRenderer;
-        boolean flag1 = this.isDrawBlockOutline();
         GlStateManager.enableCull();
+        
         this.mc.mcProfiler.endStartSection("clear");
 
-        if (flag)
-        {
-            Shaders.setViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-        }
-        else
-        {
-            GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-        }
-
-        this.updateFogColor(partialTicks);
-        GlStateManager.clear(16640);
-
-        if (flag)
-        {
-            Shaders.clearRenderBuffer();
-        }
-
+	        if (shadersMod)
+	        {
+	            Shaders.setViewport(0, 0, this.mc.displayFBWidth, this.mc.displayFBHeight);
+	        }
+	        else
+	        {
+	            GlStateManager.viewport(0, 0, this.mc.displayFBWidth, this.mc.displayFBHeight);
+	        }
+	                    
+	        this.updateFogColor(partialTicks);
+	      
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+	
+	        if (shadersMod)
+	        {
+	            Shaders.clearRenderBuffer();
+	        }
+	        
+    	this.mc.mcProfiler.endStartSection("stencil");
+			if(mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center && mc.vrSettings.vrUseStencil && mc.stereoProvider.isStereo() && mc.vrPlayer.isHMDTracking()){
+				if(shadersMod){
+					GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, Shaders.dfb);
+					Shaders.useProgram(0);
+				}
+				mc.doStencilForEye(mc.currentPass == renderPass.Left? 0 : 1); //TODO: dont render this every damn frame.				
+			}
+			else{
+				GL11.glDisable(GL11.GL_STENCIL_TEST);
+			}
+	        
         this.mc.mcProfiler.endStartSection("camera");
-        this.setupCameraTransform(partialTicks, pass);
-
-        if (flag)
-        {
-            Shaders.setCamera(partialTicks);
-        }
-
-        ActiveRenderInfo.updateRenderInfo(this.mc.thePlayer, this.mc.gameSettings.thirdPersonView == 2);
+        
+	        this.setupCameraTransform(partialTicks, pass);
+		    applyCameraDepth(false); //neat
+	        if (shadersMod)
+	        {
+	            Shaders.setCamera(partialTicks);
+	        }
+	
+//			/** MINECRIFT */ // Save our projection and modelview matrices ---- why...
+//			GL11.glMatrixMode(GL11.GL_PROJECTION);
+//			GL11.glPushMatrix();
+//			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//			GL11.glPushMatrix();
+//			/** END MINECRIFT */
+	        
+	        ActiveRenderInfo.updateRenderInfo(this.mc.thePlayer, this.mc.gameSettings.thirdPersonView == 2);
+	        
+	        GlStateManager.enableAlpha();
+	        GlStateManager.enableDepth();
+	        
         this.mc.mcProfiler.endStartSection("frustum");
-        ClippingHelperImpl.getInstance();
+        	ClippingHelperImpl.getInstance();
         this.mc.mcProfiler.endStartSection("culling");
-        ICamera icamera = new Frustum();
-        Entity entity = this.mc.getRenderViewEntity();
-        double d0 = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * (double)partialTicks;
-        double d1 = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * (double)partialTicks;
-        double d2 = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * (double)partialTicks;
-
-        if (flag)
-        {
-            ShadersRender.setFrustrumPosition(icamera, d0, d1, d2);
-        }
-        else
-        {
-            icamera.setPosition(d0, d1, d2);
-        }
-
-        if ((Config.isSkyEnabled() || Config.isSunMoonEnabled() || Config.isStarsEnabled()) && !Shaders.isShadowPass)
-        {
-            this.setupFog(-1, partialTicks);
-            this.mc.mcProfiler.endStartSection("sky");
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
-            GlStateManager.matrixMode(5888);
-
-            if (flag)
-            {
-                Shaders.beginSky();
-            }
-
-            renderglobal.renderSky(partialTicks, pass);
-
-            if (flag)
-            {
-                Shaders.endSky();
-            }
-
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
-            GlStateManager.matrixMode(5888);
-        }
-        else
-        {
-            GlStateManager.disableBlend();
-        }
-
-        this.setupFog(0, partialTicks);
-        GlStateManager.shadeModel(7425);
-
-        if (entity.posY + (double)entity.getEyeHeight() < 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F))
-        {
-            this.renderCloudsCheck(renderglobal, partialTicks, pass);
-        }
-
+	        ICamera icamera = new Frustum();
+	        Entity entity = this.mc.getRenderViewEntity();
+	        double d0 = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * (double)partialTicks;
+	        double d1 = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * (double)partialTicks;
+	        double d2 = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * (double)partialTicks;
+	
+	        if (shadersMod)
+	        {
+	            ShadersRender.setFrustrumPosition(icamera, d0, d1, d2);
+	        }
+	        else
+	        {
+	            icamera.setPosition(d0, d1, d2);
+	        }
+
+        this.mc.mcProfiler.endStartSection("sky");
+
+	        if ((Config.isSkyEnabled() || Config.isSunMoonEnabled() || Config.isStarsEnabled()) && !Shaders.isShadowPass)
+	        {///uuuh what... are...u...doing....
+	            this.setupFog(-1, partialTicks);
+	            GlStateManager.matrixMode(GL11.GL_PROJECTION);
+	            GlStateManager.pushMatrix();            
+//	            GlStateManager.matrixMode(5889);
+//	            GlStateManager.loadIdentity();
+//	            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
+	            GlStateManager.matrixMode(5888);
+
+	            if (shadersMod)
+	            {
+	                Shaders.beginSky();
+	            }
+	            
+	            renderglobal.renderSky(partialTicks, pass);
+	            
+	            if (shadersMod)
+	            {
+	                Shaders.endSky();
+	            }
+	
+	            GlStateManager.matrixMode(GL11.GL_PROJECTION);
+	            GlStateManager.popMatrix();
+	            	            
+//	            GlStateManager.matrixMode(5889);
+//	            GlStateManager.loadIdentity();
+//	            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
+	            GlStateManager.matrixMode(5888);
+	            
+
+	        }
+	        else
+	        {
+	            GlStateManager.disableBlend();
+	        }
+	
+	        this.setupFog(0, partialTicks);
+	        GlStateManager.shadeModel(7425);
+	        //VIVE NO EYE HEIGHT
+	        if (entity.posY < 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F))
+	        {
+	             this.renderCloudsCheck(renderglobal, partialTicks, pass);
+	        }
+	       	        
         this.mc.mcProfiler.endStartSection("prepareterrain");
-        this.setupFog(0, partialTicks);
-        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-        RenderHelper.disableStandardItemLighting();
+	        this.setupFog(0, partialTicks);
+	        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+	        RenderHelper.disableStandardItemLighting();
         this.mc.mcProfiler.endStartSection("terrain_setup");
 
-        if (flag)
-        {
-            ShadersRender.setupTerrain(renderglobal, entity, (double)partialTicks, icamera, this.frameCount++, this.mc.thePlayer.isSpectator());
-        }
-        else
-        {
-            renderglobal.setupTerrain(entity, (double)partialTicks, icamera, this.frameCount++, this.mc.thePlayer.isSpectator());
-        }
-
-        if (pass == 0 || pass == 2)
-        {
-            this.mc.mcProfiler.endStartSection("updatechunks");
-            Lagometer.timerChunkUpload.start();
-            this.mc.renderGlobal.updateChunks(finishTimeNano);
-            Lagometer.timerChunkUpload.end();
-        }
+	        if (shadersMod)
+	        {
+	            ShadersRender.setupTerrain(renderglobal, entity, (double)partialTicks, icamera, this.frameCount++, this.mc.thePlayer.isSpectator());
+	        }
+	        else
+	        {
+	            renderglobal.setupTerrain(entity, (double)partialTicks, icamera, this.frameCount++, this.mc.thePlayer.isSpectator());
+	        }
+	
+	        if (mc.currentPass == renderPass.Left)
+	        {
+	            this.mc.mcProfiler.endStartSection("updatechunks");
+		            Lagometer.timerChunkUpload.start();
+		            this.mc.renderGlobal.updateChunks(finishTimeNano);
+		            Lagometer.timerChunkUpload.end();
+	        }
 
         this.mc.mcProfiler.endStartSection("terrain");
-        Lagometer.timerTerrain.start();
+	        Lagometer.timerTerrain.start();
+	
+	        if (this.mc.gameSettings.ofSmoothFps && pass > 0)
+	        {
+	            this.mc.mcProfiler.endStartSection("finish");
+	            GL11.glFinish(); //do not turn this on.
+	            this.mc.mcProfiler.endStartSection("terrain");
+	        }
+	
+	        GlStateManager.matrixMode(5888);
+	        GlStateManager.pushMatrix();
+	        GlStateManager.disableAlpha();
+	
+	        if (shadersMod)
+	        {
+	            ShadersRender.beginTerrainSolid();
+	        }
+	
+	        
+	        renderglobal.renderBlockLayer(BlockRenderLayer.SOLID, (double)partialTicks, pass, entity);
+	        GlStateManager.enableAlpha();
+	
+	        if (shadersMod)
+	        {
+	            ShadersRender.beginTerrainCutoutMipped();
+	        }
+	
+	        renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, (double)partialTicks, pass, entity);
+	        this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
+	
+	        if (shadersMod)
+	        {
+	            ShadersRender.beginTerrainCutout();
+	        }
+	
+	        renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT, (double)partialTicks, pass, entity);
+	        this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+	
+	        if (shadersMod)
+	        {
+	            ShadersRender.endTerrain();
+	        }
+	
+	        Lagometer.timerTerrain.end();
+	        GlStateManager.shadeModel(7424);
+	        GlStateManager.alphaFunc(516, 0.1F);
+        
+        this.mc.mcProfiler.endStartSection("entities");
 
-        if (this.mc.gameSettings.ofSmoothFps && pass > 0)
-        {
-            this.mc.mcProfiler.endStartSection("finish");
-            GL11.glFinish();
-            this.mc.mcProfiler.endStartSection("terrain");
-        }
-
-        GlStateManager.matrixMode(5888);
-        GlStateManager.pushMatrix();
-        GlStateManager.disableAlpha();
-
-        if (flag)
-        {
-            ShadersRender.beginTerrainSolid();
-        }
-
-        renderglobal.renderBlockLayer(BlockRenderLayer.SOLID, (double)partialTicks, pass, entity);
-        GlStateManager.enableAlpha();
-
-        if (flag)
-        {
-            ShadersRender.beginTerrainCutoutMipped();
-        }
-
-        renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, (double)partialTicks, pass, entity);
-        this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-
-        if (flag)
-        {
-            ShadersRender.beginTerrainCutout();
-        }
-
-        renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT, (double)partialTicks, pass, entity);
-        this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
-
-        if (flag)
-        {
-            ShadersRender.endTerrain();
-        }
-
-        Lagometer.timerTerrain.end();
-        GlStateManager.shadeModel(7424);
-        GlStateManager.alphaFunc(516, 0.1F);
-
-        if (!this.debugView)
-        {
-            GlStateManager.matrixMode(5888);
+            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
             GlStateManager.popMatrix();
             GlStateManager.pushMatrix();
-            RenderHelper.enableStandardItemLighting();
-            this.mc.mcProfiler.endStartSection("entities");
-
-            if (Reflector.ForgeHooksClient_setRenderPass.exists())
-            {
-                Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(0)});
-            }
-
-            renderglobal.renderEntities(entity, icamera, partialTicks);
-
-            if (Reflector.ForgeHooksClient_setRenderPass.exists())
-            {
-                Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(-1)});
-            }
+	            RenderHelper.enableStandardItemLighting();
+	
+	            if (Reflector.ForgeHooksClient_setRenderPass.exists())
+	            {
+	                Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(0)});
+	            }
+	
+	            renderglobal.renderEntities(entity, icamera, partialTicks);
+	
+	    		renderCrosshairAtDepth();
+	            
+	            if (Reflector.ForgeHooksClient_setRenderPass.exists())
+	            {
+	                Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(-1)});
+	            }
+	
+        this.mc.mcProfiler.endStartSection("hands");
+	            
+		    	this.enableLightmap();    
+		        RenderHelper.enableStandardItemLighting();
+	    		itemRenderer.setLightmap();
+	    		GlStateManager.enableRescaleNormal();
+	    		
+		        this.renderHand(partialTicks, 0);
+				this.renderLeftHand(partialTicks);
+				
+		        boolean forgeHands = ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, partialTicks, pass);
+		        
+	            GlStateManager.disableRescaleNormal();
+	            RenderHelper.disableStandardItemLighting();
+	            this.disableLightmap();
+		        GlStateManager.enableTexture2D();	
+	        
 
-            RenderHelper.disableStandardItemLighting();
-            this.disableLightmap();
-        }
-
-        GlStateManager.matrixMode(5888);
+        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
         GlStateManager.popMatrix();
 
-        if (flag1 && this.mc.objectMouseOver != null && !entity.isInsideOfMaterial(Material.WATER))
-        {
-            EntityPlayer entityplayer = (EntityPlayer)entity;
-            GlStateManager.disableAlpha();
-            this.mc.mcProfiler.endStartSection("outline");
-
-            if (!Reflector.ForgeHooksClient_onDrawBlockHighlight.exists() || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {renderglobal, entityplayer, this.mc.objectMouseOver, Integer.valueOf(0), Float.valueOf(partialTicks)}))
-            {
-                renderglobal.drawSelectionBox(entityplayer, this.mc.objectMouseOver, 0, partialTicks);
-            }
-            GlStateManager.enableAlpha();
-        }
-
-        if (this.mc.debugRenderer.func_190074_a())
-        {
-            this.mc.debugRenderer.func_190073_a(partialTicks, finishTimeNano);
-        }
-
-        if (!renderglobal.damagedBlocks.isEmpty())
-        {
-            this.mc.mcProfiler.endStartSection("destroyProgress");
-            GlStateManager.enableBlend();
-            GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-            this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-            renderglobal.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), entity, partialTicks);
-            this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
-            GlStateManager.disableBlend();
-        }
-
-        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
-        GlStateManager.disableBlend();
-
-        if (!this.debugView)
-        {
-            this.enableLightmap();
-            this.mc.mcProfiler.endStartSection("litParticles");
-
-            if (flag)
-            {
-                Shaders.beginLitParticles();
-            }
-
-            particlemanager.renderLitParticles(entity, partialTicks);
-            RenderHelper.disableStandardItemLighting();
-            this.setupFog(0, partialTicks);
-            this.mc.mcProfiler.endStartSection("particles");
-
-            if (flag)
-            {
-                Shaders.beginParticles();
-            }
-
-            particlemanager.renderParticles(entity, partialTicks);
-
-            if (flag)
-            {
-                Shaders.endParticles();
-            }
-
-            this.disableLightmap();
-        }
-
-        GlStateManager.depthMask(false);
-        GlStateManager.enableCull();
+        this.mc.mcProfiler.endStartSection("outline");
+	   
+        	boolean renderOutline = this.isDrawBlockOutline();
+     
+	        if (renderOutline && this.mc.objectMouseOver != null && !itemRenderer.isInsideOfMaterial(getEyeRenderPos(mc.currentPass), Material.WATER))
+	        {
+	            EntityPlayer entityplayer = (EntityPlayer)entity;
+	            GlStateManager.disableAlpha();
+	
+	            if (!Reflector.ForgeHooksClient_onDrawBlockHighlight.exists() || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {renderglobal, entityplayer, this.mc.objectMouseOver, Integer.valueOf(0), Float.valueOf(partialTicks)}))
+	            {
+	                renderglobal.drawSelectionBox(entityplayer, this.mc.objectMouseOver, 0, partialTicks);
+	            }
+	            GlStateManager.enableAlpha();
+	        }
+	
+	        if (this.mc.debugRenderer.func_190074_a())
+	        {
+	            this.mc.debugRenderer.func_190073_a(partialTicks, finishTimeNano);
+	        }
+
+        this.mc.mcProfiler.endStartSection("destroyProgress");
+	        if (!renderglobal.damagedBlocks.isEmpty())
+	        {
+	        	GlStateManager.enableBlend();
+	            GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+	            this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
+	            renderglobal.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), entity, partialTicks);
+	            this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+	            GlStateManager.disableBlend();
+	        }
+	
+	        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
+	        GlStateManager.disableBlend();
+
+	        
+        this.mc.mcProfiler.endStartSection("litParticles");
+	        if (!this.debugView)
+	        {
+	            this.enableLightmap();
+	
+	            if (shadersMod)
+	            {
+	                Shaders.beginLitParticles();
+	            }
+	
+	            particlemanager.renderLitParticles(entity, partialTicks);
+	            RenderHelper.disableStandardItemLighting();
+	            this.setupFog(0, partialTicks);
+	     this.mc.mcProfiler.endStartSection("particles");
+	
+	            if (shadersMod)
+	            {
+	                Shaders.beginParticles();
+	            }
+	
+	            particlemanager.renderParticles(entity, partialTicks);
+	
+	            if (shadersMod)
+	            {
+	                Shaders.endParticles();
+	            }
+	
+	            this.disableLightmap();
+	        }
+	
+	        GlStateManager.depthMask(false);
+	        GlStateManager.enableCull();
         this.mc.mcProfiler.endStartSection("weather");
-
-        if (flag)
-        {
-            Shaders.beginWeather();
-        }
-
-        this.renderRainSnow(partialTicks);
-
-        if (flag)
-        {
-            Shaders.endWeather();
-        }
-
-        GlStateManager.depthMask(true);
-        renderglobal.renderWorldBorder(entity, partialTicks);
-
-        if (flag)
-        {
-            ShadersRender.renderHand0(this, partialTicks, pass);
-            Shaders.preWater();
-        }
-
-        GlStateManager.disableBlend();
-        GlStateManager.enableCull();
-        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-        GlStateManager.alphaFunc(516, 0.1F);
-        this.setupFog(0, partialTicks);
-        GlStateManager.enableBlend();
-        GlStateManager.depthMask(false);
-        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-        GlStateManager.shadeModel(7425);
+	
+	        if (shadersMod)
+	        {
+	            Shaders.beginWeather();
+	        }
+	
+	        this.renderRainSnow(partialTicks);
+	
+	        if (shadersMod)
+	        {
+	            Shaders.endWeather();
+	        }
+	
+	        GlStateManager.depthMask(true);
+	        renderglobal.renderWorldBorder(entity, partialTicks);
+	
+	        	        
+	        if (shadersMod)
+	        {
+	            Shaders.preWater();
+	        }
+	
+	        GlStateManager.disableBlend();
+	        GlStateManager.enableCull();
+	        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+	        GlStateManager.alphaFunc(516, 0.1F);
+	        this.setupFog(0, partialTicks);
+	        GlStateManager.enableBlend();
+	        GlStateManager.depthMask(false);
+	        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+	        GlStateManager.shadeModel(7425);
         this.mc.mcProfiler.endStartSection("translucent");
 
-        if (flag)
-        {
-            Shaders.beginWater();
-        }
-
-        renderglobal.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, (double)partialTicks, pass, entity);
-
-        if (flag)
-        {
-            Shaders.endWater();
-        }
-
-        if (Reflector.ForgeHooksClient_setRenderPass.exists() && !this.debugView)
-        {
-            RenderHelper.enableStandardItemLighting();
-            this.mc.mcProfiler.endStartSection("entities");
-            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(1)});
-            this.mc.renderGlobal.renderEntities(entity, icamera, partialTicks);
-            GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(-1)});
-            RenderHelper.disableStandardItemLighting();
-        }
-
-        GlStateManager.shadeModel(7424);
-        GlStateManager.depthMask(true);
-        GlStateManager.enableCull();
-        GlStateManager.disableBlend();
-        GlStateManager.disableFog();
-
-        if (entity.posY + (double)entity.getEyeHeight() >= 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F))
-        {
-            this.mc.mcProfiler.endStartSection("aboveClouds");
-            this.renderCloudsCheck(renderglobal, partialTicks, pass);
-        }
-
-        if (Reflector.ForgeHooksClient_dispatchRenderLast.exists())
-        {
-            this.mc.mcProfiler.endStartSection("forge_render_last");
-            Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {renderglobal, Float.valueOf(partialTicks)});
-        }
-
-        this.mc.mcProfiler.endStartSection("hand");
-        boolean flag2 = ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, partialTicks, pass);
-
-        if (!flag2 && this.renderHand && !Shaders.isShadowPass)
-        {
-            if (flag)
-            {
-                ShadersRender.renderHand1(this, partialTicks, pass);
-                Shaders.renderCompositeFinal();
+	        if (shadersMod)
+	        {
+	            Shaders.beginWater();
+	        }
+	
+	        renderglobal.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, (double)partialTicks, pass, entity);
+	
+	        if (shadersMod)
+	        {
+	            Shaders.endWater();
+	        }
+
+        this.mc.mcProfiler.endStartSection("forgeEntities");
+
+            if (Reflector.ForgeHooksClient_setRenderPass.exists() && !this.debugView)
+            {
+            	RenderHelper.enableStandardItemLighting();
+            	Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(1)});
+            	this.mc.renderGlobal.renderEntities(entity, icamera, partialTicks);
+            	GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+            	Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(-1)});
+            	RenderHelper.disableStandardItemLighting();
             }
 
-            GlStateManager.clear(256);
-
-            if (flag)
-            {
-                ShadersRender.renderFPOverlay(this, partialTicks, pass);
-            }
-            else
-            {
-                this.renderHand(partialTicks, pass);
-            }
-        }
+            GlStateManager.shadeModel(7424);
+            GlStateManager.depthMask(true);
+            GlStateManager.enableCull();
+            GlStateManager.disableBlend();
+            GlStateManager.disableFog();
 
-        if (flag)
-        {
-            Shaders.endRender();
-        }
+        this.mc.mcProfiler.endStartSection("aboveClouds");
+        //VIVE no eye height
+	        if (entity.posY >= 128.0D + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0F))
+	        {
+	            this.renderCloudsCheck(renderglobal, partialTicks, pass);
+	        }
+
+        this.mc.mcProfiler.endStartSection("forge_render_last");
+	        if (Reflector.ForgeHooksClient_dispatchRenderLast.exists())
+	        {
+	            Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {renderglobal, Float.valueOf(partialTicks)});
+	        }
+    
+		eyeCollisionBlock = null;// getEyeCollisionBlock(mc.currentPass);
+
+		eyeCollision = false;//eyeCollisionBlock != null && eyeCollisionBlock.isNormalCube());
+		
+//		/** MINECRIFT */ // restore our projection and modelview matrices
+//		GL11.glMatrixMode(GL11.GL_PROJECTION);
+//		GL11.glPopMatrix();
+//		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//		GL11.glPopMatrix();
+
+		if (mc.currentPass != renderPass.Third) //no fp overlay for 3rd cam.
+			this.renderFPOverlay(partialTicks);
+		
+		this.mc.mcProfiler.endStartSection("ShadersEnd");
+	        if ( shadersMod && !forgeHands && this.renderHand && !Shaders.isShadowPass)
+	        {	        	
+	        	 GL11.glDisable(GL11.GL_STENCIL_TEST);
+	        	 Shaders.renderCompositeFinal();
+	        }
+
+            if (shadersMod)
+            	Shaders.endRender(); 
+
+		
+    	this.mc.mcProfiler.endStartSection("renderGui");
+			if(!mc.bowTracker.isDrawing)				
+				renderGuiLayer(partialTicks);  
+            
+		this.mc.mcProfiler.endSection();
+
+		restoreRVEPos((EntityLivingBase) mc.getRenderViewEntity()); //unhack the RVE position.
+		((EntityPlayerSP)player).overrideEyeHeight = false;
+			
     }
 
     private void renderCloudsCheck(RenderGlobal renderGlobalIn, float partialTicks, int pass)
@@ -1896,19 +1991,19 @@
         if (this.mc.gameSettings.renderDistanceChunks >= 4 && !Config.isCloudsOff() && Shaders.shouldRenderClouds(this.mc.gameSettings))
         {
             this.mc.mcProfiler.endStartSection("clouds");
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance * 4.0F);
-            GlStateManager.matrixMode(5888);
-            GlStateManager.pushMatrix();
+//            GlStateManager.matrixMode(5889);
+//            GlStateManager.loadIdentity();
+//            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance * 4.0F);
+//            GlStateManager.matrixMode(5888);
+           GlStateManager.pushMatrix();
             this.setupFog(0, partialTicks);
             renderGlobalIn.renderClouds(partialTicks, pass);
             GlStateManager.disableFog();
             GlStateManager.popMatrix();
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
-            GlStateManager.matrixMode(5888);
+//            GlStateManager.matrixMode(5889);
+//            GlStateManager.loadIdentity();
+//            Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.clipDistance);
+//            GlStateManager.matrixMode(5888);
         }
     }
 
@@ -2206,7 +2301,7 @@
             double d0 = MathHelper.sin(world.getCelestialAngleRadians(partialTicks)) > 0.0F ? -1.0D : 1.0D;
             Vec3d vec3d2 = new Vec3d(d0, 0.0D, 0.0D);
             float f5 = (float)entity.getLook(partialTicks).dotProduct(vec3d2);
-
+            
             if (f5 < 0.0F)
             {
                 f5 = 0.0F;
@@ -2250,8 +2345,10 @@
             this.fogColorBlue *= f11;
         }
 
-        IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
+//        IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
 
+        Vec3d pos = getEyeRenderPos(mc.currentPass);
+        
         if (this.cloudFog)
         {
             Vec3d vec3d3 = world.getCloudColour(partialTicks);
@@ -2259,7 +2356,7 @@
             this.fogColorGreen = (float)vec3d3.yCoord;
             this.fogColorBlue = (float)vec3d3.zCoord;
         }
-        else if (iblockstate.getMaterial() == Material.WATER)
+        else if (itemRenderer.isInsideOfMaterial(pos, Material.WATER))
         {
             float f12 = 0.0F;
 
@@ -2285,7 +2382,7 @@
                 this.fogColorBlue = (float)vec3d4.zCoord;
             }
         }
-        else if (iblockstate.getMaterial() == Material.LAVA)
+        else if (itemRenderer.isInsideOfMaterial(pos, Material.LAVA))
         {
             this.fogColorRed = 0.6F;
             this.fogColorGreen = 0.1F;
@@ -2363,16 +2460,7 @@
             this.fogColorBlue = f7;
         }
 
-        if (Reflector.EntityViewRenderEvent_FogColors_Constructor.exists())
-        {
-            Object object = Reflector.newInstance(Reflector.EntityViewRenderEvent_FogColors_Constructor, new Object[] {this, entity, iblockstate, Float.valueOf(partialTicks), Float.valueOf(this.fogColorRed), Float.valueOf(this.fogColorGreen), Float.valueOf(this.fogColorBlue)});
-            Reflector.postForgeBusEvent(object);
-            this.fogColorRed = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_FogColors_getRed, new Object[0]);
-            this.fogColorGreen = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_FogColors_getGreen, new Object[0]);
-            this.fogColorBlue = Reflector.callFloat(object, Reflector.EntityViewRenderEvent_FogColors_getBlue, new Object[0]);
-        }
-
-        Shaders.setClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
+        Shaders.setClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0F);
     }
 
     /**
@@ -2386,8 +2474,11 @@
         GlStateManager.glFog(2918, this.setFogColorBuffer(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 1.0F));
         GlStateManager.glNormal3f(0.0F, -1.0F, 0.0F);
         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-        IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
+        //VIVE use this instead.
+        IBlockState iblockstate = mc.theWorld.getBlockState(entity.getPosition());
+        //IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.theWorld, entity, partialTicks);
         float f = -1.0F;
+        Vec3d pos = getEyeRenderPos(mc.currentPass);
 
         if (Reflector.ForgeHooksClient_getFogDensity.exists())
         {
@@ -2446,7 +2537,7 @@
 
             GlStateManager.setFogDensity(0.1F);
         }
-        else if (iblockstate.getMaterial() == Material.WATER)
+        else if (itemRenderer.isInsideOfMaterial(pos, Material.WATER))
         {
             if (Config.isShaders())
             {
@@ -2478,7 +2569,7 @@
                 GlStateManager.setFogDensity(0.02F);
             }
         }
-        else if (iblockstate.getMaterial() == Material.LAVA)
+        else if (itemRenderer.isInsideOfMaterial(pos, Material.LAVA)) //vive use my method.
         {
             if (Config.isShaders())
             {
@@ -2706,10 +2797,12 @@
             this.updatedWorld = world;
         }
 
-        if (!this.setFxaaShader(Shaders.configAntialiasingLevel))
-        {
-            Shaders.configAntialiasingLevel = 0;
-        }
+        //VIVE disable shaders AA
+        Shaders.configAntialiasingLevel = 0;        
+//        if (!this.setFxaaShader(Shaders.configAntialiasingLevel))
+//        {
+//            Shaders.configAntialiasingLevel = 0;
+//        }
     }
 
     private void frameFinish()
@@ -2733,49 +2826,6 @@
         }
     }
 
-    private void updateMainMenu(GuiMainMenu p_updateMainMenu_1_)
-    {
-        try
-        {
-            String s = null;
-            Calendar calendar = Calendar.getInstance();
-            calendar.setTime(new Date());
-            int i = calendar.get(5);
-            int j = calendar.get(2) + 1;
-
-            if (i == 8 && j == 4)
-            {
-                s = "Happy birthday, OptiFine!";
-            }
-
-            if (i == 14 && j == 8)
-            {
-                s = "Happy birthday, sp614x!";
-            }
-
-            if (s == null)
-            {
-                return;
-            }
-
-            Field[] afield = GuiMainMenu.class.getDeclaredFields();
-
-            for (int k = 0; k < afield.length; ++k)
-            {
-                if (afield[k].getType() == String.class)
-                {
-                    afield[k].setAccessible(true);
-                    afield[k].set(p_updateMainMenu_1_, s);
-                    break;
-                }
-            }
-        }
-        catch (Throwable var8)
-        {
-            ;
-        }
-    }
-
     public boolean setFxaaShader(int p_setFxaaShader_1_)
     {
         if (!OpenGlHelper.isFramebufferEnabled())
@@ -2858,4 +2908,2061 @@
         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
         GlStateManager.popMatrix();
     }
+    
+    //VIVECRAFT ADDITIONS *********************************************************
+	public void setupClipPlanes()
+	{
+		this.farPlaneDistance = (float)(mc.gameSettings.renderDistanceChunks * 16);
+
+//		if (Config.isFogFancy())
+//		{
+//			this.farPlaneDistance *= 0.95F;
+//		}
+//
+//		if (Config.isFogFast())
+//		{
+//			this.farPlaneDistance *= 0.83F;
+//		}
+
+		this.clipDistance = this.farPlaneDistance * 2.0F;
+
+		if (this.clipDistance < 128.0F)
+		{
+			this.clipDistance = 128.0F;
+		}
+
+		if (mc.theWorld != null && mc.theWorld.provider != null && mc.theWorld.provider.getDimensionType() == DimensionType.THE_END)
+		{
+			this.clipDistance = 256.0F;
+		}
+	}
+    
+
+	private void updateMainMenu(GuiMainMenu mainGui)
+	{
+		try
+		{
+			String e = null;
+			Calendar calendar = Calendar.getInstance();
+			calendar.setTime(new Date());
+			int day = calendar.get(5);
+			int month = calendar.get(2) + 1;
+
+			if (day == 8 && month == 4)
+			{
+				e = "Happy birthday, OptiFine!";
+			}
+
+			if (day == 14 && month == 8)
+			{
+				e = "Happy birthday, sp614x!";
+			}
+
+			if (e == null)
+			{
+				return;
+			}
+
+			Field[] fs = GuiMainMenu.class.getDeclaredFields();
+
+			for (int i = 0; i < fs.length; ++i)
+			{
+				if (fs[i].getType() == String.class)
+				{
+					fs[i].setAccessible(true);
+					fs[i].set(mainGui, e);
+					break;
+				}
+			}
+		}
+		catch (Throwable var8)
+		{
+			;
+		}
+	}
+
+	
+	public void doLookOverride(){
+		float PIOVER180 = (float)(Math.PI/180);
+		EntityPlayer entity = this.mc.thePlayer;
+			if(entity == null)return;
+			//This is used for all sorts of things both client and server side.
+
+			if(false){  //hmm, to use HMD?
+				//set model view direction to camera
+				entity.rotationYawHead = entity.rotationYaw = (float)mc.roomScale.getHMDYaw_World();
+				entity.rotationPitch = (float)mc.roomScale.getHMDPitch_World();
+			} else { //default to looking 'at' the crosshair position.
+				if(crossVec != null){
+					Vec3d playerToCrosshair = entity.getPositionEyes(1).subtract(crossVec); //backwards
+					double what = playerToCrosshair.yCoord/playerToCrosshair.lengthVector();
+					if(what > 1) what = 1;
+					if(what < -1) what = -1;
+					float pitch = (float)Math.toDegrees(Math.asin(what));
+					float yaw = (float)Math.toDegrees(Math.atan2(playerToCrosshair.xCoord, -playerToCrosshair.zCoord));    
+					entity.rotationYaw = yaw;
+					entity.rotationYawHead = yaw;
+					entity.rotationPitch = pitch;
+					
+				}
+			}
+
+			if(entity.isElytraFlying() || (entity.moveForward > 0 && ! mc.bowTracker.isDrawing && (mc.vrPlayer.getFreeMoveMode() || entity.isRiding()))){
+				//us laim, needed for server side movement.
+				entity.rotationYawHead = entity.rotationYaw = mc.roomScale.getControllerYaw_World(1);
+				entity.rotationPitch = - mc.roomScale.getControllerPitch_World(1);
+				
+			} else {
+				ItemStack i = ((EntityPlayerSP) entity).inventory.getCurrentItem();
+				if(i !=null){
+					if(i.getItem() instanceof ItemBow){
+						//use bow aim
+						Vec3d aim = mc.bowTracker.getAimVector();
+						if (aim != null) {
+							//backwards in 1.10 
+							float pitch = (float)Math.toDegrees(Math.asin(aim.yCoord/aim.lengthVector()));
+							float yaw = (float)Math.toDegrees(Math.atan2(aim.xCoord, -aim.zCoord));   		
+
+							entity.rotationYaw =  (float)yaw;
+							entity.rotationPitch = (float)pitch;
+							entity.rotationYawHead = yaw;							
+						}
+
+
+					}	 
+					else if(i.getItem() == Items.SNOWBALL ||
+							i.getItem() == Items.EGG  ||
+							i.getItem() == Items.SPAWN_EGG  ||
+							i.getItem() == Items.POTIONITEM  
+							) {
+						//use r_hand aim
+						entity.rotationYawHead=	entity.rotationYaw =  mc.roomScale.getControllerYaw_World(0);
+						entity.rotationPitch = mc.roomScale.getControllerPitch_World(0);
+					}
+					else if(mc.vrPlayer.shouldIlookatMyHand[0]){
+						Vec3d playerToMain = entity.getPositionEyes(1).subtract(mc.roomScale.getControllerPos_World(0)); //backwards
+						float pitch =(float)Math.toDegrees(Math.asin(playerToMain.yCoord/playerToMain.lengthVector()));
+						float yaw = (float)Math.toDegrees(Math.atan2(playerToMain.xCoord,-playerToMain.zCoord));    
+						entity.rotationYawHead  = entity.rotationYaw = yaw;
+						entity.rotationPitch = pitch;
+					}
+					else if(mc.vrPlayer.shouldIlookatMyHand[1]){
+						Vec3d playerToMain = entity.getPositionEyes(1).subtract(mc.roomScale.getControllerPos_World(1)); //backwards
+						float pitch = (float)Math.toDegrees(Math.asin(playerToMain.yCoord/playerToMain.lengthVector()));
+						float yaw = (float)Math.toDegrees(Math.atan2(playerToMain.xCoord, -playerToMain.zCoord));    
+						entity.rotationYawHead  = entity.rotationYaw = yaw;
+						entity.rotationPitch = pitch;
+					}
+				}
+			}
+			
+			
+
+			
+		}
+
+		
+	
+	/** MINECRIFT ADDITIONS BELOW **/
+
+
+	private float checkCameraCollision(
+			double camX,       double camY,       double camZ,
+			double camXOffset, double camYOffset, double camZOffset, float distance )
+	{
+		//This loop offsets at [-.1, -.1, -.1], [.1,-.1,-.1], [.1,.1,-.1] etc... for all 8 directions
+		double minDistance = -1d;
+
+		// Lets extend out the test range somewhat
+		camXOffset *= 10f;
+		camYOffset *= 10f;
+		camZOffset *= 10f;
+
+		for (int var20 = 0; var20 < 8; ++var20)
+		{
+			final float MIN_DISTANCE = 0.06F;
+			float var21 = (float)((var20 & 1) * 2 - 1);
+			float var22 = (float)((var20 >> 1 & 1) * 2 - 1);
+			float var23 = (float)((var20 >> 2 & 1) * 2 - 1);
+			var21 *= 0.1F;
+			var22 *= 0.1F;
+			var23 *= 0.1F;
+			RayTraceResult var24 = this.mc.theWorld.rayTraceBlocks(
+					new Vec3d(camX + var21, camY + var22, camZ + var23),
+					new Vec3d(camX - camXOffset + var21, camY - camYOffset + var22, camZ - camZOffset + var23));
+
+			BlockPos bp = var24.getBlockPos();
+			if (var24 != null && this.mc.theWorld.isBlockNormalCube(bp, true))
+			{
+				double var25 = var24.hitVec.distanceTo(new Vec3d(camX, camY, camZ)) - MIN_DISTANCE;
+
+				if (minDistance == -1d)
+				{
+					minDistance = var25;
+				}
+				else if (var25 < minDistance)
+				{
+					minDistance = var25;
+				}
+			}
+		}
+		if (minDistance == -1d)
+			minDistance = distance *= 10d;
+
+		return (float)minDistance;
+	}
+
+	public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+	{
+		float aspect = displayHeight / displayWidth;
+
+		GL11.glBegin(GL11.GL_QUADS);
+
+		GL11.glTexCoord2f(0.0f, 0.0f);
+		GL11.glVertex3f(-(size / 2f), -(size * aspect) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f);
+		GL11.glVertex3f(size / 2f, -(size * aspect) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f);
+		GL11.glVertex3f(size / 2f, (size * aspect) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f);
+		GL11.glVertex3f(-(size / 2f), (size * aspect) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+
+
+
+	public void handleNotificationText()
+	{
+		String prefix = "";
+		String message = "";
+		String suffix = "";
+
+		boolean renderTxt = false;
+
+		// error info takes precedence
+		if (mc.errorHelper != null) {
+			if (System.currentTimeMillis() < mc.errorHelper.endTime)
+			{
+				prefix = mc.errorHelper.title;
+				message = mc.errorHelper.message;
+				suffix = mc.errorHelper.resolution;
+				renderTxt = true;
+			}
+			else
+			{
+				mc.errorHelper = null;
+			}
+		}
+		// otherwise display any calibration info
+		if (renderTxt)
+			displayNotificationText(prefix, message, suffix,
+					this.mc.displayWidth, this.mc.displayHeight, this.mc.stereoProvider.isStereo(), !this.mc.stereoProvider.isStereo());
+	}
+
+	public void displayNotificationText(String prefix, String message, String suffix,
+			int displayWidth, int displayHeight, boolean isStereo, boolean isGuiOrtho)
+	{
+		final float INITIAL_TEXT_SCALE = isGuiOrtho ? 0.0055f : 0.00375f;
+		final int TEXT_WORDWRAP_LEN = 55;
+		final int COLUMN_GAP = 12;
+
+		float fade = isGuiOrtho ? 0.85f : 0.80f;
+		Color3f rgb = new Color3f(0f, 0f, 0f);
+	//	renderFadeBlend(rgb, fade);
+
+		// Pass matrici on to OpenGL...
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+			GL11.glLoadIdentity();
+			if (isStereo)
+			{
+				int i = mc.currentPass.value();
+				if(i>1) i = 0;
+				GL11.glMultMatrix(mc.eyeproj[i]);
+			}
+			else
+			{
+				Project.gluPerspective(90f, (float) displayWidth / (float) displayHeight, minClipDistance, clipDistance);
+			}
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+				GL11.glLoadIdentity();
+		
+				int column = 8;
+				ArrayList<String> wrapped = new ArrayList<String>();
+				if (message != null)
+					Utils.wordWrap(message, TEXT_WORDWRAP_LEN, wrapped);
+				float rows = wrapped.size();
+				float shift = rows / 2f;
+		
+				float x = isGuiOrtho ? 0f : -this.mc.vrSettings.getHalfIPD(EyeType.ovrEye_Center);
+				float y = shift * COLUMN_GAP * 0.003f; // Move up
+				float z = -0.6f;
+				boolean d = GL11.glIsEnabled(GL11.GL_DEPTH_TEST);
+				GlStateManager.disableDepth();
+				GL11.glTranslatef(x, y, z);
+				GL11.glRotatef(180f, 0.0F, 1.0F, 0.0F);
+				float textScale = (float) Math.sqrt((x * x + y * y + z * z));
+				GL11.glScalef(-INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale, -INITIAL_TEXT_SCALE * textScale);
+				if (prefix != null)
+					mc.fontRendererObj.drawStringWithShadow(prefix, -mc.fontRendererObj.getStringWidth(prefix) / 2, -8, /*white*/16777215);
+		
+				for (String line : wrapped)
+				{
+					mc.fontRendererObj.drawStringWithShadow(line, -mc.fontRendererObj.getStringWidth(line) / 2, column, /*white*/16777215);
+					column += COLUMN_GAP;
+				}
+				column += COLUMN_GAP;
+				if (suffix != null)
+					mc.fontRendererObj.drawStringWithShadow(suffix, -mc.fontRendererObj.getStringWidth(suffix) / 2, column, /*white*/16777215);
+		
+				if(d)	GlStateManager.enableDepth();
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+	}
+
+
+
+	public void getPointedBlock(float par1)
+	{
+		/** END MINECRIFT */    
+		if (this.mc.getRenderViewEntity() != null && this.mc.theWorld != null)
+		{
+			/** MINECRIFT */
+			// Lets choose to use the head position for block / entity distance hit / miss calcs for now. Lean
+			// forward, you can hit further away...
+	
+			this.mc.pointedEntity = null;
+			double blockReachDistance = mc.vrSettings.vrWorldScale * (double)this.mc.playerController.getBlockReachDistance();
+			double entityReachDistance = (double)this.mc.playerController.getBlockReachDistance();
+			// Darktemp's crosshair fix
+			// VIVE START - interact source	
+			
+			Vec3d aimsource = mc.roomScale.getControllerPos_World(0);
+			Vec3d aimsoucecopy = new Vec3d(aimsource.xCoord, aimsource.yCoord, aimsource.zCoord);
+			Vec3d aimsourcecopy2 = new Vec3d(aimsource.xCoord, aimsource.yCoord, aimsource.zCoord);
+			// VIVE END - interact source
+	
+			Vec3d aim = mc.roomScale.getControllerDir_World(0);
+			Vec3d endPos = aimsource.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+			crossVec=aimsource.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+	
+			this.mc.objectMouseOver = this.mc.theWorld.rayTraceBlocks(aimsource, endPos, false, false, true);
+			
+			//JRBUDDA - i dunno what any of this does that option isnt used.
+			
+			double maxreach = MAX_CROSSHAIR_DISTANCE;
+			
+			//   System.out.println(this.mc.objectMouseOver.toString());
+			if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit ==Type.MISS)
+			{
+				// Get MISS distance
+				if (!this.mc.vrSettings.maxCrosshairDistanceAtBlockReach) {
+					endPos = aimsoucecopy.addVector(aim.xCoord * MAX_CROSSHAIR_DISTANCE, aim.yCoord * MAX_CROSSHAIR_DISTANCE, aim.zCoord * MAX_CROSSHAIR_DISTANCE);
+					RayTraceResult crossPos = this.mc.theWorld.rayTraceBlocks(aimsoucecopy, endPos, false, false, true);
+					if (crossPos != null) {
+						crossVec = crossPos.hitVec;
+						maxreach = crossVec.distanceTo(aimsourcecopy2);
+					} else {
+						crossVec = new Vec3d(endPos.xCoord, endPos.yCoord, endPos.zCoord);
+						maxreach = crossVec.distanceTo(aimsourcecopy2);
+					}
+				}
+				this.mc.objectMouseOver = null;
+			}
+			else
+			{
+				// Get HIT distance
+				maxreach = this.mc.objectMouseOver.hitVec.distanceTo(aimsourcecopy2); // Set entityreach here - we can't hit an entity behind whatever this is...
+				crossVec = this.mc.objectMouseOver.hitVec;
+			}
+	
+			Entity pointedEntity = null;
+			Vec3d hitLocation = null;
+		
+			AxisAlignedBB bb = new AxisAlignedBB(
+					-maxreach, -maxreach, -maxreach, 
+					maxreach, maxreach, maxreach)
+					.offset(aimsourcecopy2.xCoord, aimsourcecopy2.yCoord,  aimsourcecopy2.zCoord).expand(1, 1, 1);
+			
+			List entitiesWithinCrosshairDist = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.getRenderViewEntity(), bb);
+			
+			double reach = maxreach;
+			double dist = 0;
+			
+			for (int i = 0; i < entitiesWithinCrosshairDist.size(); ++i)
+			{
+				Entity entity = (Entity)entitiesWithinCrosshairDist.get(i);
+	
+				if (entity.canBeCollidedWith())
+				{
+					float borderSize = entity.getCollisionBorderSize();
+					AxisAlignedBB boundingBox = entity.getEntityBoundingBox().expand((double)borderSize, (double)borderSize, (double)borderSize);
+					RayTraceResult collision = boundingBox.calculateIntercept(aimsourcecopy2, crossVec);
+	
+					if (boundingBox.isVecInside(aimsourcecopy2))
+					{
+						if (0.0D < reach || reach == 0.0D)
+						{
+							pointedEntity = entity;                     
+							hitLocation = collision == null ? aimsourcecopy2 : collision.hitVec;
+							reach = 0.0D;
+						}
+					}
+					else if (collision != null)
+					{
+						dist = aimsourcecopy2.distanceTo(collision.hitVec);
+	
+						if (dist < maxreach || reach == 0.0D)
+						{
+							boolean canRiderInteract = false;
+	
+							if (Reflector.ForgeEntity_canRiderInteract.exists())
+							{
+								canRiderInteract = Reflector.callBoolean(entity, Reflector.ForgeEntity_canRiderInteract, new Object[0]);
+							}
+	
+							if (entity == this.mc.thePlayer.getRidingEntity() && !canRiderInteract)
+							{
+								if (reach == 0.0D)
+								{
+									pointedEntity = entity;
+									hitLocation = collision.hitVec;
+								}
+							}
+							else
+							{
+								pointedEntity = entity;
+								hitLocation = collision.hitVec;
+							}
+						}
+					}
+				}
+			}
+			
+			if (pointedEntity != null && hitLocation !=null )
+				crossVec = hitLocation;
+			
+			if (pointedEntity != null && (dist < entityReachDistance) ) {
+				this.mc.objectMouseOver = new RayTraceResult(pointedEntity, hitLocation);
+				crossVec = this.mc.objectMouseOver.hitVec;
+	
+				if (pointedEntity instanceof EntityLivingBase || pointedEntity instanceof EntityItemFrame) {
+					this.mc.pointedEntity = pointedEntity;
+				}
+			}
+			
+	
+			// VIVE START - teleport movement
+			if (!mc.vrPlayer.getFreeMoveMode() && 
+					mc.gameSettings.keyBindForward.isKeyDown()) { 
+				mc.vrPlayer.updateTeleportDestinations(this, mc, mc.getRenderViewEntity());
+			}
+			// VIVE END - teleport movement
+			/** END MINECRIFT */    
+		}
+	}
+
+	//unused
+	public void drawLine(Vec3d start, Vec3d end)
+	{
+//		GL11.glEnable(GL11.GL_BLEND);
+//		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+//		GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
+//		GL11.glLineWidth(6.0F);
+//		GL11.glDisable(GL11.GL_TEXTURE_2D);
+//		GL11.glDepthMask(false);
+//
+//		Tessellator var2 = Tessellator.getInstance();
+////		var2.startDrawing(GL11.GL_LINE_STRIP);
+////		var2.addVertex(start.xCoord, start.yCoord, start.zCoord);
+////		var2.addVertex(end.xCoord, end.yCoord, end.zCoord);
+//		var2.draw();
+//
+//		GL11.glDepthMask(true);
+//		GL11.glEnable(GL11.GL_TEXTURE_2D);
+//		GL11.glDisable(GL11.GL_BLEND);
+	}
+
+
+
+	// Thanks to mhagain
+	public void renderFadeBlend (float r, float g, float b, float fadeAlpha, int left, int right, int bottom, int top)
+	{
+		
+		GlStateManager.enableBlend();
+		GlStateManager.disableAlpha();
+		GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+		GlStateManager.disableDepth();
+		GlStateManager.disableTexture2D();
+		
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+		GL11.glLoadIdentity();
+
+		// when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+		// it is the direction i read in, after all.  live with it, weenies.
+		GL11.glOrtho(0, this.mc.displayFBWidth, this.mc.displayFBHeight, 0, -1, 1);
+
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPushMatrix();
+			GL11.glLoadIdentity();
+	
+			GL11.glColor4f(r, g, b, fadeAlpha);
+	
+			GL11.glBegin(GL11.GL_QUADS);
+	
+			GL11.glVertex3f(left, top, 0);
+			GL11.glVertex3f(right, top, 0);
+			GL11.glVertex3f(right, bottom, 0);
+			GL11.glVertex3f(left, bottom, 0);
+	
+			GL11.glEnd();
+	
+			GL11.glDisable(GL11.GL_BLEND);
+			GL11.glEnable(GL11.GL_DEPTH_TEST);
+			GL11.glEnable(GL11.GL_TEXTURE_2D);
+	
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+	
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glPopMatrix();
+	}
+
+	
+
+	/** Renders the pre-generated 2-d framebuffer into the world at the appropriate location..
+	 * @param par1
+	 */
+	private void renderGuiLayer(float par1)
+	{
+		if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame || this.mc.showSplashScreen)
+		{
+			
+			boolean shaders = Config.isShaders();
+					
+			boolean inMenuRoom = this.mc.theWorld == null || mc.currentScreen instanceof GuiWinGame || mc.integratedServerLaunchInProgress ;
+			// Pass matrici on to OpenGL...
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glLoadIdentity();
+			
+			// Minecrift - use correct projection
+			if (this.mc.stereoProvider.isStereo() && ((mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center) || (this.mc.vrSettings.displayMirrorMode != VRSettings.MIRROR_MIXED_REALITY && this.mc.vrSettings.displayMirrorMode != VRSettings.MIRROR_FIRST_PERSON)))
+			{			
+				int i = mc.currentPass.value();
+				if(i > 1) i = 0;
+				GL11.glMultMatrix(mc.eyeproj[i]);
+			}
+			else
+			{
+				Project.gluPerspective(this.mc.gameSettings.fovSetting, this.mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY ? this.mc.vrSettings.mixedRealityAspectRatio : (float)this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+			}
+			if (mc.currentPass == renderPass.Third && this.mc.theWorld == null) {
+				GL11.glGetFloat(GL11.GL_PROJECTION_MATRIX, matrixBuffer);
+				matrixBuffer.rewind();
+				this.thirdPassProjectionMatrix.load(matrixBuffer);
+				matrixBuffer.rewind();
+			}
+	
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glLoadIdentity();
+			// VIVE START - custom GUI position
+			GL11.glPushMatrix();
+				applyGUIModelView(this.mc.currentPass); 
+	
+					///JRBUDDA MAIN MENU ROOM            
+					if(inMenuRoom){		
+						rendserJrbuddasAwesomeMainMenuRoom();			
+					}
+					//END JRBUDDA'S AWESOME MAIN MENU ROOM
+					
+					this.mc.guiFramebuffer.bindFramebufferTexture();
+
+					GlStateManager.disableCull();
+					RenderHelper.disableStandardItemLighting();    
+					GlStateManager.enableTexture2D();
+					
+					// Prevent black border at top / bottom of GUI
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+					// Set texture filtering
+					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+					GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+					GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+					if (!inMenuRoom)
+					{
+						GlStateManager.color(1, 1, 1, this.mc.vrSettings.hudOpacity);
+						GlStateManager.enableAlpha();
+					}
+					else{
+						GlStateManager.color(1, 1, 1, 1f);
+						GlStateManager.disableAlpha();
+					}
+
+					if (this.mc.vrSettings.hudOcclusion == false || this.mc.currentScreen != null){
+						// Never use depth test for in game menu - so you can always see it!
+						GlStateManager.disableDepth();		
+					} else {
+						GlStateManager.enableDepth();
+					}
+					
+
+					//the framebuffer has to be drawn with color blending transparency to support non-alpha cursors. Always has a black background.	
+					GlStateManager.disableBlend();
+
+					GlStateManager.alphaFunc(GL11.GL_GREATER, 0.01f);
+					//	OpenGlHelper.glBlendFunc(GL11.GL_ONE, GL11.GL_ONE_MINUS_SRC_COLOR, 1, 0); //color blend for corsshair transparency
+					//	OpenGlHelper.glBlendFunc(GL11.GL_ONE, GL11.GL_ZERO,0,1);
+					float scale = MCOpenVR.guiScale; // * this.mc.vroptions.hudscale
+
+					GlStateManager.scale(scale, scale, scale);
+					
+					if(mc.currentPass == renderPass.Third){
+						GlStateManager.enableDepth();
+						GlStateManager.depthMask(true);
+					}
+
+					GlStateManager.disableCull();
+
+					//Render framebuffer onto world projection
+					ScaledResolution s = new ScaledResolution(mc);
+									
+					drawSizedQuad(s.getScaledWidth(), s.getScaledHeight(), 1.5f); //this.mc.vrSettings.hudScale);
+
+
+					GlStateManager.disableBlend();
+					GlStateManager.enableDepth();
+					GlStateManager.enableCull();
+
+				}
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPopMatrix();
+
+	
+}
+
+	//VIVE
+	public void renderDebugAxes(int r, int g, int b, float radius){
+		setupPolyRendering(true);
+		renderCircle(new Vec3d(0, 0, 0), (float) radius, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0, .01, 0), (float) radius * .75f, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0,0.02, 0), (float) radius * .25f, 32, r, g, b	, 255, 0);
+		renderCircle(new Vec3d(0, 0, .15), (float) radius *.5f, 32, r, g, b	, 255, 2);
+		setupPolyRendering(false);
+	}
+
+	//TODO: move this into Guiingame where it belongs.
+	/** This draws the normal 2d menu/GUI elements to the framebuffer, to be rendered into the world projection later (in renderFramebufferIntoWorld)
+	 * @param renderPartialTicks
+	 * @param tickDuration
+	 */
+	public void drawFramebuffer(float renderPartialTicks, long tickDuration)    // VIVE - added parameter for debug info
+	{
+	
+		this.guiScreenShowingThisFrame = false;
+		this.inWorldGuiScreenShowingThisFrame = false;
+
+		int mouseX = 0;
+		int mouseY = 0;
+		final ScaledResolution var15 = new ScaledResolution(this.mc);
+
+		
+		if (false)//this.mc.showSplashScreen)
+		{
+    		this.mc.showSplash(this.mc.getFramebuffer());
+		}
+		else if (false)//(this.mc.isIntegratedServerLaunching())
+		{
+//			this.guiScreenShowingThisFrame = true;
+//			this.mc.loadingScreen.render();
+		}
+		else //always for vive, never for mono
+		{
+			if ((this.mc.theWorld != null && !this.mc.vrSettings.hideGui && this.mc.thePlayer.getSleepTimer() == 0) 
+					|| this.mc.currentScreen != null)
+			{
+								
+				//Render all UI elements into guiFBO
+				GlStateManager.clearColor(0, 0, 0, 0);
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				GlStateManager.matrixMode(GL11.GL_PROJECTION);
+				GlStateManager.loadIdentity();
+				GlStateManager.ortho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+				GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+				GlStateManager.loadIdentity();
+				GlStateManager.translate(0.0F, 0.0F, -2000.0F);
+
+
+				if (this.mc.theWorld != null && this.mc.currentScreen != null)
+					this.inWorldGuiScreenShowingThisFrame = true; // In game menus will open at look forward orient, with no depth check applied
+				else
+					this.guiScreenShowingThisFrame = true;        // Hud elements will open at body forward orient, with depth check applied if necessary
+			}
+
+			if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame)
+			{
+				// Display loading / progress window if necessary
+				if (this.mc.theWorld != null && !this.mc.vrSettings.hideGui /*&& !this.blankGUIUntilWorldValid*/)
+				{
+
+					//Draw in game HUD overlay
+					GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
+					Object fmlCommonHandler = null;
+					
+					//Render HUD elements
+					this.mc.ingameGUI.renderGameOverlay(renderPartialTicks);
+					
+					if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo)
+					{
+						Config.drawFps();
+					}
+					
+					mc.guiAchievement.updateAchievementWindow();
+
+					GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);
+				}
+
+				//        if (this.blankGUIUntilWorldValid) {
+				//            if (this.mc.theWorld != null)
+				//                this.blankGUIUntilWorldValid = false;
+				//        }
+
+				if (this.mc.currentScreen != null /*&& !this.blankGUIUntilWorldValid*/)
+				{
+					final int mouseX1 = mouseX = this.mc.currentScreen.getMouseX();
+					final int mouseY1 = mouseY = this.mc.currentScreen.getMouseY();
+
+					try
+					{
+						boolean drawScreenHandled = false;
+
+
+						if (!drawScreenHandled)
+						{
+							this.mc.currentScreen.drawScreen(mouseX, mouseY, renderPartialTicks);
+
+							if(mc.currentScreen !=null){ 
+
+								//	Draw GUI crosshair
+								if (mc.stereoProvider.isStereo()){					
+									if(MCOpenVR.controllerMouseValid)
+										mc.ingameGUI.drawMouseMenuQuad(mc.currentScreen.getMouseX(),mc.currentScreen.getMouseY());				
+								} else 
+									mc.ingameGUI.drawMouseMenuQuad(mc.currentScreen.getMouseX(),mc.currentScreen.getMouseY());
+								
+							}
+						}
+
+					}
+					catch (Throwable throwable)
+					{
+//						CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Rendering screen");
+//						CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
+//						crashreportcategory.addCrashSectionCallable("Screen name", new Callable() {
+//							private static final String __OBFID = "CL_00000948";
+//
+//							public String call() {
+//								return Minecraft.getMinecraft().currentScreen.getClass().getCanonicalName();
+//							}
+//						});
+//						crashreportcategory.addCrashSectionCallable("Mouse location", new Callable() {
+//							private static final String __OBFID = "CL_00000950";
+//
+//							public String call() {
+//								return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[]{Integer.valueOf(mouseX1), Integer.valueOf(mouseY1), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
+//							}
+//						});
+//						crashreportcategory.addCrashSectionCallable("Screen size", new Callable() {
+//							private static final String __OBFID = "CL_00000951";
+//
+//							public String call() {
+//								return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[]{Integer.valueOf(var15.getScaledWidth()), Integer.valueOf(var15.getScaledHeight()), Integer.valueOf(Minecraft.getMinecraft().displayWidth), Integer.valueOf(Minecraft.getMinecraft().displayHeight), Integer.valueOf(var15.getScaleFactor())});
+//							}
+//						});
+//						throw new ReportedException(crashreport);
+					}
+
+					GlStateManager.disableLighting();
+					GlStateManager.blendFunc(SourceFactor.SRC_ALPHA, DestFactor.ONE_MINUS_SRC_ALPHA);
+					//inventory messes up fog color sometimes... This fixes
+				
+
+				}
+			}
+		}
+
+		// VIVE added debug info to HUD
+		if (mc.gameSettings.showDebugInfo && mc.gameSettings.showDebugProfilerChart)
+		{
+			mc.displayDebugInfo(tickDuration);
+		}
+
+		//update mipmaps for Gui layer
+		this.mc.getFramebuffer().bindFramebufferTexture();
+		this.mc.getFramebuffer().genMipMaps();
+		this.mc.getFramebuffer().unbindFramebufferTexture();
+		
+	}
+
+
+	private void renderTeleportArc(OpenVRPlayer vrPlayer) {
+
+		if ( vrPlayer.vrMovementStyle.showBeam && vrPlayer.movementTeleportProgress > 0.0f
+				&& vrPlayer.movementTeleportArcSteps > 1)
+		{
+			mc.mcProfiler.startSection("teleportArc");
+
+			boolean isShader = Config.isShaders();
+		
+			Tessellator tes = Tessellator.getInstance();
+			tes.getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
+			
+				double VOffset = vrPlayer.lastTeleportArcDisplayOffset;
+	
+				boolean validLocation = (vrPlayer.movementTeleportDestination.xCoord != 0
+						|| vrPlayer.movementTeleportDestination.yCoord != 0
+						|| vrPlayer.movementTeleportDestination.zCoord != 0);
+	
+				int validLineR = 205;
+				int validLineG = 169;
+				int validLineB = 205;
+				
+				Vec4b color;
+
+				
+				if (!validLocation)
+				{
+					// invalid location
+					color = new Vec4b((byte)83, (byte)75, (byte)83, (byte)128);
+				}
+				else
+				{
+					color = new Vec4b((byte)validLineR, (byte)validLineG, (byte)validLineB, (byte)255);
+					VOffset = this.mc.stereoProvider.getCurrentTimeSecs()*vrPlayer.vrMovementStyle.textureScrollSpeed * 0.6;
+					vrPlayer.lastTeleportArcDisplayOffset = VOffset;
+				}
+	
+				float segmentHalfWidth = vrPlayer.vrMovementStyle.beamHalfWidth * 0.15f;
+				int segments = vrPlayer.movementTeleportArcSteps - 1;
+				if (vrPlayer.vrMovementStyle.beamGrow)
+				{
+					segments = (int) ((double) segments * vrPlayer.movementTeleportProgress);
+				}
+				double segmentProgress = 1.0 / (double) segments;
+	
+				Vec3d up = new Vec3d(0,1,0);
+	
+				for (int i=0;i<segments;i++)
+				{
+					double progress = ((double)i / (double)segments) + VOffset * segmentProgress;
+					int progressBase = (int)MathHelper.floor_double(progress);
+					progress -= (float) progressBase;
+	
+					Vec3d start = mc.vrPlayer.getInterpolatedArcPosition((float)(progress - segmentProgress * 0.4f))
+							.subtract(mc.getRenderViewEntity().getPositionVector());
+
+	
+					Vec3d end = mc.vrPlayer.getInterpolatedArcPosition((float)progress)
+							.subtract(mc.getRenderViewEntity().getPositionVector());
+	
+					float shift = (float)progress * 2.0f;
+					renderBox(tes, start, end, -segmentHalfWidth, segmentHalfWidth, (-1.0f + shift ) * segmentHalfWidth, (1.0f + shift) * segmentHalfWidth, up, color);
+				}
+				
+			tes.draw();
+
+			if (validLocation){ //draw landing splash
+			
+				Vec3d circlePos = new Vec3d(vrPlayer.movementTeleportDestination.xCoord, vrPlayer.movementTeleportDestination.yCoord, vrPlayer.movementTeleportDestination.zCoord) 
+						.subtract(mc.getRenderViewEntity().getPositionVector());
+
+				int side = 1; //vrPlayer.movementTeleportDestinationSideHit;
+
+				float o = 0.01f;
+				
+				double x = 0;
+				double y = 0;
+				double z = 0;
+
+				if (side ==0)   y -= o;
+				if (side ==1)   y += o;
+				if (side ==2)   z -= o;
+				if (side ==3)   z += o;
+				if (side ==4)   x -= o;
+				if (side ==5)   x += o;						
+				renderCircle(circlePos.addVector(x, y, z), 0.2f, 32, (int)(validLineR*1.03), (int)(validLineG*1.03), (int)(validLineB*1.03), isShader ? 255 : 64,side);
+				if (side ==0)   y -= o;
+				if (side ==1)   y += o;
+				if (side ==2)   z -= o;
+				if (side ==3)   z += o;
+				if (side ==4)   x -= o;
+				if (side ==5)   x += o;
+				renderCircle(circlePos.addVector(x, y, z), 0.15f, 32, (int)(validLineR*1.04), (int)(validLineG*1.04), (int)(validLineB*1.04), isShader ? 255 : 64,side);
+				if (side ==0)   y -= o;
+				if (side ==1)   y += o;
+				if (side ==2)   z -= o;
+				if (side ==3)   z += o;
+				if (side ==4)   x -= o;
+				if (side ==5)   x += o;
+				renderCircle(circlePos.addVector(x, y, z), 0.1f, 32, (int)(validLineR*1.05), (int)(validLineG*1.05), (int)(validLineB*1.05), isShader ? 255 : 64,side);
+			}
+
+			mc.mcProfiler.endSection(); // teleport arc
+		}
+	}
+
+
+	//please push your matrix first. and pop after.
+	public void SetupRenderingAtController(int controller){
+		Vec3d aimSource = this.getControllerRenderPos(controller).
+				subtract(mc.getRenderViewEntity().getPositionVector());
+		
+		if (aimSource!=null)
+		{ //move from head to hand origin.
+				GL11.glTranslatef(
+					(float) (aimSource.xCoord ),
+					(float) (aimSource.yCoord ),
+					(float) (aimSource.zCoord ));
+		}
+		
+
+		
+			GL11.glScalef(mc.vrSettings.vrWorldScale , mc.vrSettings.vrWorldScale , mc.vrSettings.vrWorldScale );
+		
+    //    	Vector3f fore = new Vector3f(0,0,1);       
+   //     	Matrix4f rotation = this.mc.vrPlayer.get.getAimRotation(controller);  
+        	
+        	FloatBuffer buf = mc.roomScale.getControllerMatrix_World(controller);
+        	
+	    	if(!mc.bowTracker.isDrawing || controller == 0){ //doing this elsewhere
+	    		GL11.glMultMatrix(buf);      
+        	}     
+	    	
+	}
+	
+	// VIVE START - render functions
+	public void renderLeftHand(float nano)
+	{
+		boolean shadersMod = Config.isShaders();
+		boolean shadersModShadowPass = false;
+		
+		//from player face to HMD
+		setupCameraTransform(nano, 0);
+		applyCameraDepth(false);
+		if(shadersMod){
+			shadersModShadowPass = Shaders.isShadowPass;
+			Shaders.readCenterDepth();
+			Shaders.beginHand();
+		}
+		else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPushMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+		}
+			
+			GL11.glPushMatrix();
+
+				SetupRenderingAtController(1);	//does not push
+
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+		
+				mc.getTextureManager().bindTexture(mc.thePlayer.getLocationSkin());
+	
+		        GlStateManager.enableRescaleNormal();
+					if(mc.bowTracker.isActive(mc.thePlayer)){ //render bow
+						int c = 1;
+						if (mc.vrSettings.vrReverseShootingEye) c = 0;
+						itemRenderer.renderItemInFirstPerson(mc.thePlayer, nano, 0, EnumHand.OFF_HAND, mc.thePlayer.getSwingProgress(nano), mc.thePlayer.getHeldItemMainhand(), 0);
+					}
+					else //just hand
+						itemRenderer.renderItemInFirstPerson(mc.thePlayer, nano, 0, EnumHand.OFF_HAND, mc.thePlayer.getSwingProgress(nano), mc.thePlayer.getHeldItemOffhand(), 0);
+			    GlStateManager.disableRescaleNormal();
+		
+
+			GL11.glPopMatrix();//back to hmd rendering
+					
+											
+			setupPolyRendering(true);
+			
+					//	TP energy
+				if (mc.vrSettings.vrLimitedSurvivalTeleport && !mc.vrPlayer.getFreeMoveMode() && mc.playerController.isNotCreative() && mc.vrPlayer.vrMovementStyle.arcAiming && !mc.bowTracker.isActive(mc.thePlayer)){
+					GL11.glPushMatrix();
+						SetupRenderingAtController(1);	//does not push
+			
+						Vec3d start = new Vec3d(0,0.005,.03);
+			
+						float r;
+						float max = .015f;
+						if (mc.vrPlayer.movementTeleportProgress > 0 ) {      	
+							r = (float) ( mc.vrPlayer.getTeleportEnergy() - 4 * mc.vrPlayer.movementTeleportDistance  ) / 100 * max;
+						} else {     	
+							r = mc.vrPlayer.getTeleportEnergy() / 100 * max;
+						}
+			
+						if(r<0){r=0;}
+						GlStateManager.disableDepth();
+						renderCircle(start.addVector(0, .05001, 0), r, 32, 255, 163, 255, 128, 1);
+						renderCircle(start.addVector(0, .05, 0), max, 32, 255, 163, 255, 50, 1);    
+			
+					GL11.glPopMatrix();
+				}
+				
+				if(!mc.vrPlayer.getFreeMoveMode()){ //actually rendered from the head, not hand.
+					GL11.glPushMatrix();	
+					setupPolyRendering(true);
+					GlStateManager.enableDepth();
+						if(mc.vrPlayer.vrMovementStyle.arcAiming) {						
+							renderTeleportArc(mc.vrPlayer);
+						} else {
+							renderTeleportLine(mc.vrPlayer); 	
+						}	
+						setupPolyRendering(false);
+					GL11.glPopMatrix();
+				}
+				
+				setupPolyRendering(false);
+			
+		if(shadersMod)
+			Shaders.endHand();
+		else {
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPopMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPopMatrix();
+		}	
+	}
+
+	private void renderMainMenuHands()
+	{
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glPushMatrix();
+			GL11.glLoadIdentity();
+			if (this.mc.stereoProvider.isStereo() && mc.currentPass != renderPass.Third && mc.currentPass != renderPass.Center)
+			{
+				int i = mc.currentPass.value();
+				if(i>1) i = 0;
+				GL11.glMultMatrix(mc.eyeproj[i]);
+			} else {
+				Project.gluPerspective(this.mc.gameSettings.fovSetting, this.mc.vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY ? this.mc.vrSettings.mixedRealityAspectRatio : (float)this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+			}
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+				GL11.glLoadIdentity();
+		
+				GlStateManager.disableTexture2D();
+				GlStateManager.disableAlpha();
+				GlStateManager.disableDepth();
+						
+				// counter head rotation
+				if (mc.currentPass != renderPass.Third) {
+					GL11.glMultMatrix(mc.roomScale.getHMDMatrix_World());
+				} else {
+					GL11.glRotatef(mc.vrSettings.vrFixedCamrotPitch, 1.0F, 0.0F, 0.0F);
+					GL11.glRotatef(mc.vrSettings.vrFixedCamrotYaw - mc.vrSettings.vrWorldRotation, 0.0F, 1.0F, 0.0F);
+					GL11.glRotatef(mc.vrSettings.vrFixedCamrotRoll, 0.0F, 0.0F, 1.0F);
+				}
+
+				
+				//OK SO when world == null the origin is at your face.
+							
+				Tessellator tes = Tessellator.getInstance();
+		
+				for (int c=0;c<2;c++)
+				{
+		
+					Vec4b color = new Vec4b((byte)(255 - 127 * c), (byte)(255 - 127 * c), (byte)(255 - 127 * c), (byte)255);
+					
+					Vec3d controllerPos = this.getEyeRenderPos(mc.currentPass).subtract(this.getControllerRenderPos(c));
+					
+					GL11.glPushMatrix();
+										
+						GL11.glTranslatef(
+								(float)-controllerPos.xCoord,
+								(float)-controllerPos.yCoord,
+								(float)-controllerPos.zCoord);
+				
+						Vec3d start = new Vec3d(0,0,0);
+			
+//						Matrix4f controllerRotation = mc.lookaimController.getAimRotation(c);
+//						Vector3f forward = new Vector3f(0,0,-0.17f);
+//						Vector3f dir = controllerRotation.transform(forward);
+						Vec3d dir = mc.roomScale.getControllerDir_World(c);
+						Vec3d up = mc.roomScale.getCustomControllerVector(c, new Vec3d(0, 1, 0));
+				
+						Vec3d end = new Vec3d(
+								start.xCoord - dir.xCoord*.18,
+								start.yCoord - dir.yCoord*.18,
+								start.zCoord - dir.zCoord*.18);
+			
+						tes.getBuffer().begin(7, DefaultVertexFormats.POSITION_COLOR);
+						renderBox(tes, start, end, -0.02f, 0.02f, -0.025f, 0.00f, up, color);
+						tes.draw();
+					GL11.glPopMatrix();     
+				}
+		
+			
+				GlStateManager.enableTexture2D();
+
+			GL11.glPopMatrix();
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+	GL11.glPopMatrix();
+	}
+
+	public void renderCircle(Vec3d pos, float radius, int edges, int r, int g, int b, int a, int side)
+	{
+		Tessellator tes = Tessellator.getInstance();
+
+		boolean blend = GL11.glIsEnabled(GL11.GL_BLEND);
+		boolean tex =  GL11.glIsEnabled(GL11.GL_TEXTURE_2D);
+		boolean light =  GL11.glIsEnabled(GL11.GL_LIGHTING);
+		boolean cull =  GL11.glIsEnabled(GL11.GL_CULL_FACE);
+
+		
+		GlStateManager.enableBlend();
+		GlStateManager.blendFunc(SourceFactor.SRC_ALPHA,DestFactor.ONE_MINUS_SRC_ALPHA);
+		GlStateManager.disableTexture2D();
+		GlStateManager.disableLighting();
+		GlStateManager.disableCull();
+		
+		tes.getBuffer().begin(GL11.GL_TRIANGLE_FAN,DefaultVertexFormats.POSITION_COLOR);
+
+		tes.getBuffer().pos(pos.xCoord, pos.yCoord, pos.zCoord).color(r, g, b, a).endVertex();
+
+		for (int i=0;i<edges + 1;i++)
+		{
+			float startAngle;
+			startAngle = ( (float) (i) / (float) edges ) * (float) Math.PI * 2.0f;
+
+			if (side == 0 || side == 1) { //y
+				float x = (float) pos.xCoord + (float) Math.cos(startAngle) * radius;
+				float y = (float) pos.yCoord;
+				float z = (float) pos.zCoord + (float) Math.sin(startAngle) * radius;
+				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+			} else if (side == 2 || side == 3) { //z
+				float x = (float) pos.xCoord + (float) Math.cos(startAngle) * radius;
+				float y = (float) pos.yCoord + (float) Math.sin(startAngle) * radius;
+				float z = (float) pos.zCoord; 
+				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+			} else if (side == 4 || side == 5){ //x
+				float x = (float) pos.xCoord ;
+				float y = (float) pos.yCoord + (float) Math.cos(startAngle) * radius;
+				float z = (float) pos.zCoord + (float) Math.sin(startAngle) * radius;
+				tes.getBuffer().pos(x, y, z).color(r, g, b, a).endVertex();
+			} else{}
+
+		}
+		
+		tes.draw();       
+
+		if(!blend){GlStateManager.disableBlend();}
+		if (tex){GlStateManager.enableTexture2D();}
+		if(light){GlStateManager.enableLighting();}
+		if(cull){GlStateManager.disableCull();;}
+	}
+
+	private void renderBox(Tessellator tes, Vec3d start, Vec3d end, float minX, float maxX, float minY, float maxY, Vec3d up, Vec4b color)
+	{
+		Vec3d forward = start.subtract(end).normalize();
+		Vec3d right = forward.crossProduct(up);
+		up = right.crossProduct(forward);
+	
+		Vec3d left = new Vec3d(
+				right.xCoord * minX,
+				right.yCoord * minX,
+				right.zCoord * minX);
+	
+		right = right.scale(maxX);
+		
+	
+		Vec3d down = new Vec3d(
+				up.xCoord * minY,
+				up.yCoord * minY,
+				up.zCoord * minY);
+	
+		up = up.scale(maxY);
+
+	
+		Vec3d backRightBottom    = start.addVector(   right.xCoord+down.xCoord,   right.yCoord+down.yCoord,   right.zCoord+down.zCoord);
+		Vec3d backRightTop       = start.addVector(   right.xCoord+up.xCoord,     right.yCoord+up.yCoord,     right.zCoord+up.zCoord);
+		Vec3d backLeftBottom     = start.addVector(   left.xCoord+down.xCoord,    left.yCoord+down.yCoord,    left.zCoord+down.zCoord);
+		Vec3d backLeftTop        = start.addVector(   left.xCoord+up.xCoord,      left.yCoord+up.yCoord,      left.zCoord+up.zCoord);
+		Vec3d frontRightBottom   = end.addVector(     right.xCoord+down.xCoord,   right.yCoord+down.yCoord,   right.zCoord+down.zCoord);
+		Vec3d frontRightTop      = end.addVector(     right.xCoord+up.xCoord,     right.yCoord+up.yCoord,     right.zCoord+up.zCoord);
+		Vec3d frontLeftBottom    = end.addVector(     left.xCoord+down.xCoord,    left.yCoord+down.yCoord,    left.zCoord+down.zCoord);
+		Vec3d frontLeftTop       = end.addVector(     left.xCoord+up.xCoord,      left.yCoord+up.yCoord,      left.zCoord+up.zCoord);
+	
+		VertexBuffer b = tes.getBuffer();
+		
+		b.pos(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();    // back
+	
+		b.pos(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();   // front
+		b.pos(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+	
+		b.pos(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();    // right
+		b.pos(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+	
+		b.pos(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex(); // left
+		b.pos(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+	
+		b.pos(backLeftTop.xCoord, backLeftTop.yCoord, backLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backRightTop.xCoord, backRightTop.yCoord, backRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontRightTop.xCoord, frontRightTop.yCoord, frontRightTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(frontLeftTop.xCoord, frontLeftTop.yCoord, frontLeftTop.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();       // top
+	
+		b.pos(frontLeftBottom.xCoord, frontLeftBottom.yCoord, frontLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();       // bottom
+		b.pos(frontRightBottom.xCoord, frontRightBottom.yCoord, frontRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backRightBottom.xCoord, backRightBottom.yCoord, backRightBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+		b.pos(backLeftBottom.xCoord, backLeftBottom.yCoord, backLeftBottom.zCoord).color(color.getType(), color.getX(), color.getY(), color.getRotation()).endVertex();
+	}
+
+	//awesome.
+	private void rendserJrbuddasAwesomeMainMenuRoom() {
+		GlStateManager.clearColor(.1f, .1f, .1f, 0f);       
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);        
+		GlStateManager.color(0.5f, 0.5f, 0.5f, 1f);
+		
+		RenderHelper.enableStandardItemLighting();
+		
+		Minecraft.getMinecraft().renderEngine.bindTexture(Gui.OPTIONS_BACKGROUND);
+		
+	//	float yo = -camRelY;
+		float s = 3f;
+		int repeat = 30; 
+		int w = 5;
+		
+		GL11.glPushMatrix();
+		GL11.glScalef(2f, 2f, 2f);
+	
+			GL11.glTranslatef(0f, 0, 1.3f);
+	
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, setFogColorBuffer(0f,0f,-0.2f,1));           
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, setFogColorBuffer(1,1,1,1));
+				GL11.glLight(GL11.GL_LIGHT0, GL11.GL_AMBIENT, setFogColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+				GL11.glLightModel(GL11.GL_LIGHT_MODEL_AMBIENT, setFogColorBuffer(0, 0, 0, 1.0F));
+				GL11.glShadeModel(GL11.GL_SMOOTH);
+	
+				for (int i = 0; i <= 6; i++) {
+					GL11.glPushMatrix();
+						float t = -1.4f;
+	
+						if (i == 1) GL11.glRotatef(90f, 0,1, 0);
+						if (i == 2) GL11.glRotatef(-90f, 0,1, 0);
+						if (i == 3) GL11.glRotatef(180f, 0,1, 0);
+						if (i == 4) GL11.glRotatef(-180f, 0,1, 0);
+						if (i == 5){
+							t= -.6f;
+							GL11.glRotatef(90, 1,0, 0);
+						}
+						if (i == 6) {
+							t= (float) -1.3f/2f;
+							GL11.glRotatef(-90, 1,0, 0);
+						}
+	
+						GL11.glTranslatef(0f, 0, t);			        	
+						GL11.glBegin(GL11.GL_QUADS);	  	
+							GL11.glTexCoord2f(0.0f, 0.0f);
+							GL11.glVertex3f(-(s / 2f), -(s * 1) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+							GL11.glTexCoord2f(repeat, 0.0f);
+							GL11.glVertex3f(s / 2f, -(s * 1) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+							GL11.glTexCoord2f(repeat, repeat);
+							GL11.glVertex3f(s / 2f, (s * 1) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+							GL11.glTexCoord2f(0.0f, repeat);
+							GL11.glVertex3f(-(s / 2f), (s * 1) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+						GL11.glEnd();       
+					GL11.glPopMatrix();   	   
+	
+				}         
+	
+				GL11.glTranslatef(0f, 0, -1.3f);
+				
+			GL11.glPopMatrix();     
+	
+	}
+
+	private void renderTeleportLine(OpenVRPlayer vrPlayer){
+		// VIVE START - render teleport line
+//	
+//		boolean renderTeleportLine = vrPlayer.movementTeleportDestination.xCoord != 0
+//				|| vrPlayer.movementTeleportDestination.yCoord != 0
+//				|| vrPlayer.movementTeleportDestination.zCoord != 0;
+//		if (renderTeleportLine && vrPlayer.movementTeleportProgress>0.0 && vrPlayer.vrMovementStyle.showBeam
+//				)
+//		{
+//			mc.mcProfiler.startSection("teleportLine");
+//	
+//			float alpha = 0.3f;
+//			GL11.glColor4f(1.0f, 1.0f, 1.0f, alpha);
+//			GL11.glDisable(GL11.GL_LIGHTING);
+//			this.mc.getTextureManager().bindTexture(vrPlayer.vrMovementStyle.texture);
+//			GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
+//			GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);
+//			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+//			GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+//			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+//			GL11.glDisable(GL11.GL_CULL_FACE);
+//	
+//			Tessellator tes = Tessellator.getInstance();
+//			//tes.startDrawingQuads();
+//	
+//			Vec3d start = mc.vrPlayer.getControllerOffhandDir_World();
+//			start.xCoord -= interpolatedPlayerPos.xCoord;
+//			start.yCoord -= interpolatedPlayerPos.yCoord;
+//			start.zCoord -= interpolatedPlayerPos.zCoord;
+//			//Vec3d start = new Vec3d(0.2, 0.5, 0);
+//			Vec3d end = new Vec3d(vrPlayer.movementTeleportDestination.xCoord - interpolatedPlayerPos.xCoord,
+//					vrPlayer.movementTeleportDestination.yCoord - interpolatedPlayerPos.yCoord,
+//					vrPlayer.movementTeleportDestination.zCoord - interpolatedPlayerPos.zCoord);
+//			Vec3d delta = start.subtract(end);
+//			Vec3d forward = delta.normalize();
+//			Vec3d up = new Vec3d(0,1,0);
+//			Vec3d right = forward.crossProduct(up);
+//			float distance = (float) delta.lengthVector();
+//	
+//			float segmentLength = vrPlayer.vrMovementStyle.beamSegmentLength;
+//			float segmentHalfWidth = vrPlayer.vrMovementStyle.beamHalfWidth;
+//	
+//			int segments = (int) (distance / segmentLength);
+//			if (vrPlayer.vrMovementStyle.beamGrow)
+//			{
+//				segments = (int) ((double) segments * vrPlayer.movementTeleportProgress);
+//			}
+//			segments++;
+//	
+//			if (distance<1.5f)
+//				segments = 0;
+//	
+//			int textureVStrips = vrPlayer.vrMovementStyle.beamVStrips;
+//			float textureVStripHeight = 1.0f / (float)textureVStrips;
+//			Vec3d segmentOrigin = new Vec3d(0,0,0);
+//			Vec3d BL = new Vec3d(0,0,0);
+//			Vec3d BR = new Vec3d(0,0,0);
+//			Vec3d SBL = new Vec3d(0,0,0);
+//			Vec3d SBR = new Vec3d(0,0,0);
+//	
+//			for (int i=0;i<segments;i++)
+//			{
+//				float segmentDistance = segmentLength * i;
+//				segmentOrigin.xCoord = start.xCoord + forward.xCoord*segmentDistance;
+//				segmentOrigin.yCoord = start.yCoord + forward.yCoord*segmentDistance;
+//				segmentOrigin.zCoord = start.zCoord + forward.zCoord*segmentDistance;
+//	
+//				float VOffset = (float) -this.mc.stereoProvider.getCurrentTimeSecs()*vrPlayer.vrMovementStyle.textureScrollSpeed;
+//				VOffset += (i%textureVStrips)*textureVStripHeight;
+//	
+//				if (i==0)
+//				{
+//					BL.xCoord = segmentOrigin.xCoord - right.xCoord * segmentHalfWidth;
+//					BL.yCoord = segmentOrigin.yCoord - right.yCoord * segmentHalfWidth;
+//					BL.zCoord = segmentOrigin.zCoord - right.zCoord * segmentHalfWidth;
+//	
+//					BR.xCoord = segmentOrigin.xCoord + right.xCoord * segmentHalfWidth;
+//					BR.yCoord = segmentOrigin.yCoord + right.yCoord * segmentHalfWidth;
+//					BR.zCoord = segmentOrigin.zCoord + right.zCoord * segmentHalfWidth;
+//	
+//					SBL.xCoord = segmentOrigin.xCoord - up.xCoord * segmentHalfWidth;
+//					SBL.yCoord = segmentOrigin.yCoord - up.yCoord * segmentHalfWidth;
+//					SBL.zCoord = segmentOrigin.zCoord - up.zCoord * segmentHalfWidth;
+//	
+//					SBR.xCoord = segmentOrigin.xCoord + up.xCoord * segmentHalfWidth;
+//					SBR.yCoord = segmentOrigin.yCoord + up.yCoord * segmentHalfWidth;
+//					SBR.zCoord = segmentOrigin.zCoord + up.zCoord * segmentHalfWidth;
+//				}
+//	
+//				float progress = (float)(i+0.5f)/(float)segments;
+//				if (vrPlayer.vrMovementStyle.beamArc)
+//				{
+//					float arcHeight = (float) Math.sin(progress * Math.PI) * 1.0f;
+//					float arcRight = arcHeight * 0.15f;
+//					Vec3d arc = new Vec3d(up.xCoord * arcHeight + right.xCoord * arcRight,
+//							up.yCoord * arcHeight + right.yCoord * arcRight,
+//							up.zCoord * arcHeight + right.zCoord * arcRight);
+//					segmentOrigin.xCoord += arc.xCoord;
+//					segmentOrigin.yCoord += arc.yCoord;
+//					segmentOrigin.zCoord += arc.zCoord;
+//				}
+//	
+//				if (vrPlayer.vrMovementStyle.beamSpiral)
+//				{
+//					float angle = (float) ((segmentDistance / 2.0f) * 2 * Math.PI);
+//					float spiralHeight = vrPlayer.vrMovementStyle.beamSpiralRadius;
+//					float distanceLeft = distance - (segmentDistance + segmentLength);
+//					if (distanceLeft < 3.0f)
+//					{
+//						spiralHeight *= (distanceLeft / 3.0f);
+//					}
+//	
+//					Vec3d spiral = new Vec3d(
+//							up.xCoord * spiralHeight * (float) Math.sin(angle)
+//							+ right.xCoord * spiralHeight * Math.cos(angle),
+//							up.yCoord * spiralHeight * (float) Math.sin(angle)
+//							+ right.yCoord * spiralHeight * Math.cos(angle),
+//							up.zCoord * spiralHeight * (float) Math.sin(angle)
+//							+ right.zCoord * spiralHeight * Math.cos(angle)
+//							);
+//					segmentOrigin.xCoord += spiral.xCoord;
+//					segmentOrigin.yCoord += spiral.yCoord;
+//					segmentOrigin.zCoord += spiral.zCoord;
+//				}
+//	
+//				if (vrPlayer.vrMovementStyle.beamWave)
+//				{
+//					float waveDistance = distance;//Math.min(6.0f, distance);
+//					if (distance * vrPlayer.movementTeleportProgress < waveDistance)
+//					{
+//						float waveAmount = (float) Math.sin(segmentDistance * Math.PI * 2) * 0.1f;
+//						waveAmount *= (1.0f - (distance * vrPlayer.movementTeleportProgress / waveDistance));
+//						Vec3d wave = new Vec3d(right.xCoord * waveAmount,
+//								right.yCoord * waveAmount,
+//								right.zCoord * waveAmount);
+//						segmentOrigin.xCoord += wave.xCoord;
+//						segmentOrigin.yCoord += wave.yCoord;
+//						segmentOrigin.zCoord += wave.zCoord;
+//					}
+//				}
+//	
+//				Vec3d FL = segmentOrigin.addVector(forward.xCoord * segmentLength - right.xCoord * segmentHalfWidth,
+//						forward.yCoord * segmentLength - right.yCoord * segmentHalfWidth,
+//						forward.zCoord * segmentLength - right.zCoord * segmentHalfWidth);
+//				Vec3d FR = segmentOrigin.addVector(forward.xCoord * segmentLength + right.xCoord * segmentHalfWidth,
+//						forward.yCoord * segmentLength + right.yCoord * segmentHalfWidth,
+//						forward.zCoord * segmentLength + right.zCoord * segmentHalfWidth);
+//	
+////				tes.addVertexWithUV(BL.xCoord, BL.yCoord, BL.zCoord, 0, 0+VOffset);       // top
+////				tes.addVertexWithUV(FL.xCoord, FL.yCoord, FL.zCoord, 0, textureVStripHeight+VOffset);
+////				tes.addVertexWithUV(FR.xCoord, FR.yCoord, FR.zCoord, 1, textureVStripHeight+VOffset);
+////				tes.addVertexWithUV(BR.xCoord, BR.yCoord, BR.zCoord, 1, 0+VOffset);
+//	
+//				// render again at 90 degrees
+//				Vec3d SFL = segmentOrigin.addVector(forward.xCoord * segmentLength - up.xCoord * segmentHalfWidth,
+//						forward.yCoord * segmentLength - up.yCoord * segmentHalfWidth,
+//						forward.zCoord * segmentLength - up.zCoord * segmentHalfWidth);
+//				Vec3d SFR = segmentOrigin.addVector(forward.xCoord * segmentLength + up.xCoord * segmentHalfWidth,
+//						forward.yCoord * segmentLength + up.yCoord * segmentHalfWidth,
+//						forward.zCoord * segmentLength + up.zCoord * segmentHalfWidth);
+//	
+//				if (vrPlayer.vrMovementStyle.renderVerticalStrip)
+//				{
+////					tes.addVertexWithUV(SBL.xCoord, SBL.yCoord, SBL.zCoord, 0, 0 + VOffset);       // top
+////					tes.addVertexWithUV(SFL.xCoord, SFL.yCoord, SFL.zCoord, 0, textureVStripHeight + VOffset);
+////					tes.addVertexWithUV(SFR.xCoord, SFR.yCoord, SFR.zCoord, 1, textureVStripHeight + VOffset);
+////					tes.addVertexWithUV(SBR.xCoord, SBR.yCoord, SBR.zCoord, 1, 0 + VOffset);
+//				}
+//	
+//				BL=FL;
+//				BR=FR;
+//				SBL=SFL;
+//				SBR=SFR;
+//			}
+//			tes.draw();
+//	
+//			GL11.glEnable(GL11.GL_CULL_FACE);
+//			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+//	
+//			mc.mcProfiler.endSection(); // "teleportLine"	
+//		}
+	}
+
+	//checks around the eye position for an opaque block or water block so we can render fog and overlays for that eye
+	public Block getEyeCollisionBlock(EyeType eye){
+		//TODO this has to be totally redone and it may not be necessary anymore.
+//		Vec3d exact = mc.roomScale.getEyePos_World(eye);
+//		int var2 = (int) Math.floor(exact.xCoord);
+//		int var3 = (int) Math.floor(exact.yCoord);
+//		int var4 = (int) Math.floor(exact.zCoord);
+//	
+//		float l =	BlockLiquid.getLiquidHeightPercent(mc.theWorld.getBlockMetadata(var2, var3, var4));
+//		Block b = 	this.mc.theWorld.getBlock(var2, var3, var4);
+//	
+//		if (b.isNormalCube() ||
+//				(b.getMaterial() == Material.water && 
+//				(this.mc.theWorld.getBlock(var2, var3 +1 , var4).getMaterial() == Material.water  ||
+//				exact.yCoord - var3 < (1- l )) 
+//						)  
+//				) //head in block
+//		{          	
+//			eyeCollisionBlockPosLoc = new Vec3d(var2, var3, var4);
+//			return this.mc.theWorld.getBlock(var2, var3, var4);
+//		}
+//		else
+//		{
+//			for (int var6 = 0; var6 < 8; ++var6)
+//			{
+//				float var7 = ((float)((var6 >> 0) % 2) - 0.5F) * .07f;
+//				float var8 = ((float)((var6 >> 1) % 2) - 0.5F) * .07f;
+//				float var9 = ((float)((var6 >> 2) % 2) - 0.5F) * .07f;
+//				int var10 = MathHelper.floor_double(exact.xCoord + var7);
+//				int var11 = MathHelper.floor_double(exact.yCoord + var8);
+//				int var12 = MathHelper.floor_double(exact.zCoord + var9);
+//	
+//				if (this.mc.theWorld.getBlock(var10, var11, var12).isNormalCube())
+//				{
+//					eyeCollisionBlockPosLoc = new Vec3d(var10, var11, var12);
+//					return this.mc.theWorld.getBlock(var10, var11, var12);
+//				}
+//			}          
+//		}
+//	
+	return null;
+	
+	}
+
+	public BlockPos getCameraBlock(){
+		Vec3d cam = mc.roomScale.getHMDPos_World();
+		return new BlockPos(Math.floor(cam.xCoord), Math.floor(cam.yCoord), Math.floor(cam.zCoord));
+	}
+
+	public Vec3d getEyeBlock(renderPass eye){
+		Vec3d cam = mc.roomScale.getEyePos_World(eye);
+		return new Vec3d(Math.floor(cam.xCoord), Math.floor(cam.yCoord), Math.floor(cam.zCoord));
+	}
+
+	public boolean cameraIsInOpaqueBlock(){
+	
+		if (mc.theWorld.getBlockState(getCameraBlock()).isNormalCube())
+		{
+			return true;
+		}
+	
+		return false;
+	}
+
+	public void renderCrosshairAtDepth()
+	{
+		//Draw crosshair
+		boolean renderCrosshair = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+				(this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.vrSettings.hideGui);
+		
+		// VIVE start - don't render crosshair while teleporting
+		if (mc.vrPlayer.movementTeleportProgress>0.0f)
+		{
+			renderCrosshair = false;
+		}
+		// VIVE end
+		
+		if( this.mc.currentScreen == null && this.mc.gameSettings.thirdPersonView == 0 && renderCrosshair && !MCOpenVR.keyboardShowing && !mc.bowTracker.isDrawing)
+		{
+			this.mc.mcProfiler.endStartSection("crosshair");
+			GlStateManager.color(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+			float crossDepth =(float)crossVec.subtract(mc.roomScale.getControllerPos_World(0)).lengthVector();
+			if (crossDepth > MAX_CROSSHAIR_DISTANCE) crossDepth = MAX_CROSSHAIR_DISTANCE;
+			float depthscale = 0.4f + 0.6f*( (MAX_CROSSHAIR_DISTANCE - crossDepth) / MAX_CROSSHAIR_DISTANCE);
+			float scale = (float) (0.15f* this.mc.vrSettings.crosshairScale * Math.sqrt(mc.vrSettings.vrWorldScale));
+			scale/=(depthscale);
+			GL11.glPushMatrix();
+				GL11.glTranslatef(crossX, crossY, crossZ);
+				GL11.glRotatef(-mc.vrPlayer.getControllerYaw_World(0), 0.0F, 1.0F, 0.0F);
+				GL11.glRotatef(-mc.roomScale.getControllerPitch_World(0), 1.0F, 0.0F, 0.0F);
+				
+				if (this.mc.vrSettings.crosshairRollsWithHead)
+					GL11.glRotated(this.cameraRoll, 0.0F, 0.0F, 1.0F);
+				if (this.mc.vrSettings.crosshairScalesWithDistance)
+				{
+					// VIVE START - adjust depth scaling to handle far crosshair positions
+					scale = -0.05f;
+					GL11.glScalef(scale, scale, scale); // VIVE
+					// VIVE END - adjust depth scaling to handle far crosshair positions
+				}
+				else
+					GL11.glScalef(-scale, -scale, scale);
+				GlStateManager.disableLighting();
+				
+				if (!this.mc.vrSettings.useCrosshairOcclusion)	GlStateManager.disableDepth();
+				GlStateManager.enableBlend();
+				
+		        GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE_MINUS_DST_COLOR, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR);
+								
+				if (mc.objectMouseOver == null) {
+	
+					
+					GL11.glRotatef(45, 0, 0, 1);
+				}
+				
+				this.mc.getTextureManager().bindTexture(Gui.ICONS);
+				
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
+				GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+	
+				float var7 = 0.00390625F;
+				float var8 = 0.00390625F;
+				
+				VertexBuffer b = Tessellator.getInstance().getBuffer();
+				b.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);	
+				
+				b.pos(- 1, + 1, 0).tex( 0     , 15* var8).endVertex();
+				b.pos(+ 1, + 1, 0).tex( 15*var7, 15* var8).endVertex();
+				b.pos(+ 1, - 1, 0).tex( 15*var7, 0       ).endVertex();
+				b.pos(- 1, - 1, 0).tex( 0      , 0       ).endVertex();		
+				
+				Tessellator.getInstance().draw();
+				
+		        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+				
+				GlStateManager.disableBlend();
+				GlStateManager.enableDepth();
+				GlStateManager.color(1, 1, 1, 1);
+			GL11.glPopMatrix();
+		}
+	
+	
+	}
+	
+	public void renderFadeBlend(float r, float g, float b,  float fadeAlpha)
+	{
+		renderFadeBlend(r, g, b, fadeAlpha, 0, this.mc.displayFBWidth, this.mc.displayFBHeight, 0);
+	}
+
+	public void renderFadeEffects()
+	{
+		//        float overallFade = 0f;
+		//        Color3f rgb = new Color3f(0f, 0f, 0f);
+		//
+		//        // Determine pos track based fade
+		//        float posTrackFade = 0f;
+		//        if (this.mc.theWorld != null && this.mc.vrSettings.posTrackBlankOnCollision == true)
+		//        {
+		//            if (this.headCollision)
+		//            {
+		//                posTrackFade = 1f;
+		//                //this.mc.printChatMessage("Collision");
+		//            }
+		//            else if (this.headCollisionDistance != -1f && this.headCollisionDistance < this.headCollisionThresholdDistance)
+		//            {
+		//                posTrackFade = 1f - ((1f / this.headCollisionThresholdDistance) * this.headCollisionDistance);
+		//                //this.mc.printChatMessage("Collision in " + fadeBlend);
+		//            }
+		//            //else
+		//             //this.mc.printChatMessage("No collision");
+		//        }
+		//
+		//        float vrComfortFade = 0f;
+		//        if (this.mc.theWorld != null && this.mc.lookaimController != null && this.mc.vrSettings.useVrComfort != VRSettings.VR_COMFORT_OFF)
+		//        {
+		//            float yawRatchet = (float)this.mc.lookaimController.ratchetingYawTransitionPercent();
+		//            float pitchRatchet = (float)this.mc.lookaimController.ratchetingPitchTransitionPercent();
+		//
+		//            if (this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_BLANK)
+		//            {
+		//                if (yawRatchet > -1f || pitchRatchet > -1f)
+		//                {
+		//                    vrComfortFade = 1f;
+		//                }
+		//            }
+		//            else if(this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_FADE)
+		//            {
+		//                if (yawRatchet > -1f || pitchRatchet > -1f)
+		//                {
+		//                    vrComfortFade = Math.max(yawRatchet, pitchRatchet);
+		//                    if (vrComfortFade < 40f)
+		//                    {
+		//                        vrComfortFade = (vrComfortFade / 40f);
+		//                    }
+		//                    else if (vrComfortFade > 60f)
+		//                    {
+		//                        vrComfortFade = ((100f - vrComfortFade) / 40f);
+		//                    }
+		//                    else
+		//                    {
+		//                        vrComfortFade = 1f;
+		//                    }
+		//                }
+		//            }
+		//        }
+		//
+		//        overallFade = Math.max(posTrackFade, vrComfortFade);
+		//
+		//        if (overallFade > 0f)
+		//            renderFadeBlend(rgb, overallFade);
+	}
+	
+    
+	private Vec3d getControllerRenderPos(int c){
+		Vec3d out ;
+
+		if(mc.vrSettings.seated){	
+			Vec3d dir = mc.roomScale.getHMDDir_World();
+			dir = dir.rotateYaw((float) Math.toRadians(c==0?-35:35));
+			dir = new Vec3d(dir.xCoord, 0, dir.zCoord);
+			dir = dir.normalize();
+			if(mc.getRenderViewEntity() != null && mc.theWorld != null){
+				out = mc.getRenderViewEntity().getPositionVector().addVector(dir.xCoord*0.3 * mc.vrSettings.vrWorldScale, -0.4* mc.vrSettings.vrWorldScale ,dir.zCoord*0.3* mc.vrSettings.vrWorldScale);
+			} else {
+				out = mc.roomScale.getHMDPos_Room().addVector(dir.xCoord*0.3 , -0.4 ,dir.zCoord*0.3);
+			}
+			return out;
+		} else {
+			out= mc.roomScale.getControllerPos_Room(c);
+			out = out.rotateYaw(mc.vrPlayer.worldRotationRadians);
+		}
+		
+		return out.addVector(interPolatedRoomOrigin.xCoord, interPolatedRoomOrigin.yCoord, interPolatedRoomOrigin.zCoord);
+	}
+    
+	public Vec3d getEyeRenderPos(renderPass currentPass){
+		if (currentPass == renderPass.Center){
+			Vec3d out = mc.roomScale.getHMDPos_Room();
+			out = out.rotateYaw(mc.vrPlayer.worldRotationRadians);
+			return out.addVector(interPolatedRoomOrigin.xCoord, interPolatedRoomOrigin.yCoord, interPolatedRoomOrigin.zCoord);
+		} else if (currentPass == renderPass.Third){
+			Vec3d out = new Vec3d(mc.vrSettings.vrFixedCamposX *mc.vrSettings.vrWorldScale, mc.vrSettings.vrFixedCamposY *mc.vrSettings.vrWorldScale, mc.vrSettings.vrFixedCamposZ *mc.vrSettings.vrWorldScale);
+			out = out.rotateYaw(mc.vrPlayer.worldRotationRadians);
+			return interPolatedRoomOrigin.addVector(out.xCoord, out.yCoord, out.zCoord);
+		} else {
+			Vec3d out = mc.roomScale.getEyePos_Room(currentPass);
+			out = out.rotateYaw(mc.vrPlayer.worldRotationRadians);
+			return out.addVector(interPolatedRoomOrigin.xCoord, interPolatedRoomOrigin.yCoord, interPolatedRoomOrigin.zCoord);	
+		}
+	}
+    
+    private  void applyGUIModelView(renderPass currentPass)
+	{
+   		mc.mcProfiler.startSection("applyGUIModelView");
+	
+   			if(mc.theWorld == null)	mc.vrPlayer.worldRotationRadians = 0;
+		
+			Vec3d eye =mc.entityRenderer.getEyeRenderPos(currentPass);
+			if (mc.theWorld==null || mc.currentScreen instanceof GuiWinGame ) {
+				eye = mc.roomScale.getEyePos_Room(currentPass);
+			}
+			Vector3f guipos = MCOpenVR.guiPos_World;
+			
+			Matrix4f guirot = MCOpenVR.guiRotationPose; 
+			Vec3d guiLocal = new Vec3d(0, 0, 0);		
+	
+			if(guipos == null){
+				guipos = new Vector3f();
+				guirot = new Matrix4f();
+							
+				if (mc.theWorld!=null && (mc.currentScreen==null || mc.vrSettings.floatInventory == false))
+				// HUD view - attach to head or controller
+				{
+					
+					int i = 1;
+					if (mc.vrSettings.vrReverseHands) i = -1;
+					
+					if(mc.currentPass != renderPass.Third)
+						eye = mc.roomScale.getEyePos_World(currentPass); //dont need interpolation.
+					else {
+						eye = new Vec3d(mc.vrSettings.vrFixedCamposX *mc.vrSettings.vrWorldScale , mc.vrSettings.vrFixedCamposY *mc.vrSettings.vrWorldScale, mc.vrSettings.vrFixedCamposZ *mc.vrSettings.vrWorldScale);
+						eye = eye.rotateYaw(mc.vrPlayer.worldRotationRadians);
+						eye = mc.roomScale.getRoomOriginPos_World().addVector(eye.xCoord, eye.yCoord, eye.zCoord);
+					}
+					MCOpenVR.guiScale = mc.vrSettings.vrWorldScale;
+					if (mc.vrSettings.seated || mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_HEAD)
+					{
+						Matrix4f rot = Matrix4f.rotationY((float) Math.toRadians(mc.vrSettings.vrWorldRotation));
+						Matrix4f max = Matrix4f.multiply(rot, MCOpenVR.hmdRotation);
+
+						Vec3d v = mc.vrPlayer.getHMDPos_World();
+						Vec3d d = mc.vrPlayer.getHMDDir_World();
+						guipos.x = (float) (v.xCoord + d.xCoord*mc.vrSettings.vrWorldScale);
+						guipos.y = (float) (v.yCoord + d.yCoord*mc.vrSettings.vrWorldScale);
+						guipos.z = (float) (v.zCoord + d.zCoord*mc.vrSettings.vrWorldScale);
+
+						Quatf orientationQuat = OpenVRUtil.convertMatrix4ftoRotationQuat(max);
+
+						guirot = new Matrix4f(orientationQuat);
+
+						//float pitchOffset = (float) Math.toRadians( -mc.vrSettings.hudPitchOffset );
+						//float yawOffset = (float) Math.toRadians( -mc.vrSettings.hudYawOffset );
+						//guiRotationPose = Matrix4f.multiply(guiRotationPose, OpenVRUtil.rotationXMatrix(yawOffset));
+						//guiRotationPose = Matrix4f.multiply(guiRotationPose, Matrix4f.rotationY(pitchOffset));
+						guirot.M[3][3] = 1.0f;
+
+					}
+					else if (mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_HAND)//hud on hand
+					{
+						Matrix4f out = MCOpenVR.getAimRotation(1);
+						Matrix4f rot = Matrix4f.rotationY((float) Math.toRadians(mc.vrSettings.vrWorldRotation));
+						Matrix4f MguiRotationPose =  Matrix4f.multiply(rot,out);
+						//	MguiRotationPose.M[1][3] = 0.5f;
+						//guiRotationPose = mc.vrPlayer.getControllerMatrix_World(1);
+						guirot = Matrix4f.multiply(MguiRotationPose, OpenVRUtil.rotationXMatrix((float) Math.PI * -0.2F));
+						guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.1F * i));
+						guirot.M[3][3] = 1.7f;
+
+						guiLocal = new Vec3d(guiLocal.xCoord, 0.5*mc.vrSettings.vrWorldScale,guiLocal.zCoord);
+								
+						Vec3d v =mc.vrPlayer.getControllerPos_World(1);
+						guipos.x = (float) v.xCoord;
+						guipos.y = (float) v.yCoord;
+						guipos.z = (float) v.zCoord;
+						
+						MCOpenVR.hudPopup = true;
+						
+					}
+					else if (mc.vrSettings.vrHudLockMode == mc.vrSettings.HUD_LOCK_WRIST)//hud on wrist
+					{
+												
+						Matrix4f out = MCOpenVR.getAimRotation(1);
+						Matrix4f rot = Matrix4f.rotationY((float) Math.toRadians(mc.vrSettings.vrWorldRotation));
+						guirot =  Matrix4f.multiply(rot,out);
+
+						guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.3f *i));				
+						
+						Vector3f forward = new Vector3f(0,0,1);
+						Vector3f guiNormal = guirot.transform(forward);
+						
+						Vec3d facev = mc.roomScale.getHMDDir_World();
+						Vector3f face = new Vector3f((float)facev.xCoord, (float)facev.yCoord, (float)facev.zCoord);
+						
+						float dot = face.dot(guiNormal);
+		
+						
+						Vec3d v =mc.vrPlayer.getControllerPos_World(1);
+						guipos.x = (float)(v.xCoord);
+						guipos.y = (float) v.yCoord;
+						guipos.z = (float) v.zCoord;
+						
+						guiLocal = new Vec3d(
+						 -0.005*mc.vrSettings.vrWorldScale,
+					  	0.16*mc.vrSettings.vrWorldScale,
+						 0.19*mc.vrSettings.vrWorldScale);
+
+						Vec3d head = mc.roomScale.getHMDPos_World();
+						
+						
+						Vector3f headv = guipos.subtract(new Vector3f((float)head.xCoord, (float)head.yCoord, (float)head.zCoord)).normalised();
+						if(headv == null) return;
+						float dot2 = (float) headv.dot(guiNormal);
+						
+						if(MCOpenVR.hudPopup){
+							MCOpenVR.hudPopup = Math.abs(dot2) > 0.5 &&  dot < -0.7;
+						}else {
+							MCOpenVR.hudPopup = Math.abs(dot2) > 0.9 &&  dot < -0.97;	
+						}
+														
+						if(MCOpenVR.hudPopup){
+							MCOpenVR.guiScale = .5f*mc.vrSettings.vrWorldScale;
+						}else {
+							MCOpenVR.guiScale = 0.33f*mc.vrSettings.vrWorldScale;
+							guiLocal = new Vec3d(
+							 i*-0.12f*mc.vrSettings.vrWorldScale,
+							 0.1*mc.vrSettings.vrWorldScale,
+							 0.06*mc.vrSettings.vrWorldScale);
+							guirot = Matrix4f.multiply(guirot, Matrix4f.rotationY((float) Math.PI * 0.2f*i ));		
+						}
+					
+					}
+				} 
+			} else {
+				guipos = guipos.add(new Vector3f((float)interPolatedRoomOrigin.xCoord,
+						(float) interPolatedRoomOrigin.yCoord, (float) interPolatedRoomOrigin.zCoord));
+			}
+			// otherwise, looking at inventory screen. use pose calculated when screen was opened
+			//where is this set up... should be here....
+			
+			// counter head rotation
+			if (currentPass != renderPass.Third) {
+					GL11.glMultMatrix(mc.roomScale.getHMDMatrix_World());
+			} else {
+				GL11.glRotatef(mc.vrSettings.vrFixedCamrotPitch, 1.0F, 0.0F, 0.0F);
+				GL11.glRotatef(mc.vrSettings.vrFixedCamrotYaw - mc.vrSettings.vrWorldRotation, 0.0F, 1.0F, 0.0F);
+				GL11.glRotatef(mc.vrSettings.vrFixedCamrotRoll, 0.0F, 0.0F, 1.0F);
+			}
+			
+			
+			GL11.glTranslatef((float) (guipos.x - eye.xCoord), (float)(guipos.y - eye.yCoord), (float)(guipos.z - eye.zCoord));
+//		
+//			// offset from eye to gui pos
+			GL11.glMultMatrix(guirot.transposed().toFloatBuffer());
+			GL11.glTranslatef((float)guiLocal.xCoord, (float) guiLocal.yCoord, (float)guiLocal.zCoord);
+		
+				//double timeOpen = getCurrentTimeSecs() - startedOpeningInventory;
+	
+	
+				//		if (timeOpen < 1.5) {
+				//			scale = (float)(Math.sin(Math.PI*0.5*timeOpen/1.5));
+				//		}
+	
+			mc.mcProfiler.endSection();
+	
+	} 
+    
+	private int polyblendsrc, polyblenddst, prog;
+	private boolean polyblend, polytex, polylight, polycull;
+    
+	private void setupPolyRendering(boolean enable){
+		boolean shadersMod = Config.isShaders();
+		boolean shadersModShadowPass = false;
+		if(enable){
+			polyblendsrc = GL11.glGetInteger(GL11.GL_BLEND_SRC);
+			polyblenddst = GL11.glGetInteger(GL11.GL_BLEND_DST);
+			polyblend = GL11.glIsEnabled(GL11.GL_BLEND);
+			polytex =  GL11.glIsEnabled(GL11.GL_TEXTURE_2D);
+			polylight =  GL11.glIsEnabled(GL11.GL_LIGHTING);
+			polycull =  GL11.glIsEnabled(GL11.GL_CULL_FACE);
+			
+			GlStateManager.enableBlend();
+	        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+	        GlStateManager.disableTexture2D();
+	        GlStateManager.disableLighting();
+	        GlStateManager.disableCull();
+			if(shadersMod){
+				prog  = Shaders.activeProgram;
+				Shaders.useProgram(0);
+			}
+		} else {
+			GL11.glBlendFunc(polyblendsrc, polyblenddst);
+			if (!polyblend) GlStateManager.disableBlend(); 
+			if (polytex) GlStateManager.enableTexture2D();
+			if (polylight) GlStateManager.enableLighting();
+			if (polycull) GlStateManager.enableCull();
+			if(shadersMod && polytex)
+				Shaders.useProgram(prog);
+		}
+	}
+    
+	private double rveX, rveY, rveZ, rvelastX, rvelastY, rvelastZ, rveprevX, rveprevY, rveprevZ;
+	private float rveyaw, rvepitch, rvelastyaw, rvelastpitch;
+	private boolean cached;
+	private void cacheRVEPos(EntityLivingBase e){
+		if (mc.getRenderViewEntity() == null) return;
+		if (cached) 
+			return;
+		rveX = e.posX;
+		rveY = e.posY;
+		rveZ = e.posZ;
+		rvelastX = e.lastTickPosX;
+		rvelastY = e.lastTickPosY;
+		rvelastZ = e.lastTickPosZ;
+		rveprevX = e.prevPosX;
+		rveprevY = e.prevPosY;
+		rveprevZ = e.prevPosZ;	
+		rveyaw = e.rotationYawHead;
+		rvepitch = e.rotationPitch;
+		rvelastyaw = e.prevRotationYawHead;
+		rvelastpitch = e.prevRotationPitch;
+	}
+	
+	private void restoreRVEPos(EntityLivingBase e){
+		if (e == null) return;
+		e.posX = rveX;
+		e.posY = rveY;
+		e.posZ = rveZ;
+		e.lastTickPosX = rvelastX;
+		e.lastTickPosY = rvelastY;
+		e.lastTickPosZ = rvelastZ;
+		e.prevPosX = rveprevX;
+		e.prevPosY = rveprevY;
+		e.prevPosZ = rveprevZ;
+		e.rotationYaw = rveyaw;
+		e.rotationPitch = rvepitch;
+		e.prevRotationYaw = rvelastyaw;
+		e.prevRotationPitch = rvelastpitch;
+		e.rotationYawHead = rveyaw;
+		e.prevRotationYawHead = rvelastyaw;
+		cached = false;
+	}
+	
+	private void renderFPOverlay(float par1){
+		boolean shadersMod = Config.isShaders();
+		if (shadersMod) {
+			//just disables caps
+			Shaders.beginFPOverlay();
+		}
+		
+		if (this.mc.gameSettings.thirdPersonView == 0)
+		{
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glLoadIdentity();
+			this.itemRenderer.renderOverlays(par1);
+
+			if(this.mc.vrSettings.vrShowBlueCircleBuddy){ 	//blue circle buddy	  - have to draw here so it sits on top of overlays (face in block)
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glPushMatrix();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glPushMatrix();
+				GlStateManager.loadIdentity();
+					setupCameraTransform(par1, 0);
+					applyCameraDepth(false);
+					
+					Vec3d o = getEyeRenderPos(renderPass.Center );
+					if (mc.currentPass == renderPass.Third) o =getEyeRenderPos(renderPass.Third);
+					
+					Vec3d pos = interpolatedPlayerPos.subtract(o).addVector(0, 0.02, 0);
+					//Vec3d pos = o.subtract(interpolatedPlayerPos).addVector(0, 0.02, 0);
+					Vec3d pos2 = o.subtract(mc.roomScale.getHMDPos_World());
+					setupPolyRendering(true);
+					//renderCircle(pos2, 0.1f * mc.vrSettings.vrWorldScale, 32, 255, 255, 0, 255, 1);
+						if(eyeCollision ){
+							int was = GL11.glGetInteger(GL11.GL_DEPTH_FUNC);
+							GL11.glDepthFunc(GL11.GL_ALWAYS);
+							renderCircle(pos, 0.05f * mc.vrSettings.vrWorldScale, 32, 0, 255, 255, 128, 1);
+							GL11.glDepthFunc(was);
+						}  else {
+							renderCircle(pos, .05f * mc.vrSettings.vrWorldScale, 32, 0, 255, 255, 48, 1);            		
+						}
+						
+					setupPolyRendering(false);
+						
+					GL11.glMatrixMode(GL11.GL_PROJECTION);
+					GL11.glPopMatrix();
+					GL11.glMatrixMode(GL11.GL_MODELVIEW);
+					GL11.glPopMatrix();
+			}
+		}
+		
+		
+		if(mc.vrSettings.displayMirrorMode == mc.vrSettings.MIRROR_MIXED_REALITY){
+			//render the camera
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glPushMatrix();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glPushMatrix();
+				setupCameraTransform(par1, 0);
+				applyCameraDepth(false);
+				
+				Vec3d cam = getEyeRenderPos(renderPass.Third);
+				
+				Vec3d o = getEyeRenderPos(renderPass.Center );
+				
+				Vec3d pos = cam.subtract(o).addVector(0, 0.02, 0);
+				
+				GL11.glTranslated(pos.xCoord, pos.yCoord, pos.zCoord);
+				
+				GL11.glRotatef(-mc.vrSettings.vrFixedCamrotRoll, 0.0F, 0.0F, 1.0F);
+				GL11.glRotatef(-mc.vrSettings.vrFixedCamrotYaw + mc.vrSettings.vrWorldRotation, 0.0F, 1.0F, 0.0F);
+				GL11.glRotatef(mc.vrSettings.vrFixedCamrotPitch, 1.0F, 0.0F, 0.0F);
+				
+				setupPolyRendering(true);
+					renderDebugAxes(0, 0, 0, 0.08f * mc.vrSettings.vrWorldScale); //TODO: camera model?
+				setupPolyRendering(false);
+					
+				GL11.glMatrixMode(GL11.GL_PROJECTION);
+				GL11.glPopMatrix();
+				GL11.glMatrixMode(GL11.GL_MODELVIEW);
+				GL11.glPopMatrix();
+			
+		}
+		
+		if (shadersMod) {
+			//does nothing at all.
+			Shaders.endFPOverlay();
+		}
+		
+	}
+	// VIVE END - render functions
+    
 }
